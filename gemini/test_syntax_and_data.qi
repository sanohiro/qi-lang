; test_syntax_and_data.qi
; このファイルはQi言語の基本的な構文とデータ構造の網羅的なテストです。
; 意図: 様々なリテラルやデータ構造が正しく評価されることを確認します。

(use test :only [run assert-eq])

(run "Comments Test" (fn []
  ; これは一行コメントです。評価時に無視されるはずです。
  (assert-eq 1 1) ; 行末コメントも同様に無視されるはずです。
))

(run "Numeric Literals Test" (fn []
  ; 意図: 整数、浮動小数点数、負数、アンダースコア区切りが正しく評価されるか。
  (assert-eq 42 42)
  (assert-eq 3.14 3.14)
  (assert-eq -10 -10)
  (assert-eq 1000000 1_000_000)
))

(run "String Literals Test" (fn []
  ; 意図: ダブルクォート、エスケープシーケンス、複数行文字列が正しく機能するか。
  (assert-eq "hello" "hello")
  (assert-eq "hello\nworld" "hello
world")
  (assert-eq "say \"hello\"" "say \"hello\"")
  (assert-eq "multi-line\nstring" """multi-line
string""")
))

(run "f-string Interpolation Test" (fn []
  ; 意図: f-stringが変数や式を正しく展開できるか。
  (let [name "Qi" value 42 data [1 2]]
    (assert-eq "Hello, Qi!" f"Hello, {name}!")
    (assert-eq "Value is 42" f"Value is {value}")
    (assert-eq "Calculation: 6" f"Calculation: {(* 2 3)}")
    (assert-eq "Data: [1 2]" f"Data: {data}")
    (assert-eq "Escaped: {name}" f"Escaped: \{{name\}}"))
))

(run "Boolean and Nil Literals Test" (fn []
  ; 意図: true, false, nilがそれぞれ正しい値として評価され、if文で期待通りに動作するか。
  (assert-eq true true)
  (assert-eq false false)
  (assert-eq nil nil)
  (assert-eq "no" (if nil "yes" "no"))
  (assert-eq "no" (if false "yes" "no"))
  (assert-eq "yes" (if 0 "yes" "no")) ; 0はtruthy
  (assert-eq "yes" (if "" "yes" "no")) ; 空文字列はtruthy
))

(run "Keyword Test" (fn []
  ; 意図: キーワードがリテラルとして、またマップアクセスのための関数として機能するか。
  (let [user {:name "Alice" :age 30}]
    (assert-eq :name :name)
    (assert-eq "Alice" (:name user))
    (assert-eq 30 (:age user))
    (assert-eq nil (:email user)) ; 存在しないキーはnilを返す
  )
))

(run "Vector Literals Test" (fn []
  ; 意図: 空、単一要素、複数要素、混合型、ネストしたベクターが正しく構築されるか。
  (assert-eq [] [])
  (assert-eq [1] [1])
  (assert-eq [1 2 3] [1, 2, 3,]) ; 末尾のカンマは許容されるべき
  (assert-eq [1 "a" true] [1 "a" true])
  (assert-eq [[1 2] [3 4]] [[1 2] [3 4]])
))

(run "Map Literals Test" (fn []
  ; 意図: 空、キーワードキー、文字列キー、混合値、ネストしたマップが正しく構築されるか。
  (assert-eq {} {})
  (assert-eq {:a 1 :b 2} {:a 1, :b 2,}) ; 末尾のカンマ
  (assert-eq {"a" 1} {"a" 1})
  (assert-eq {:data [1 2] :meta {:status "ok"}} {:data [1 2] :meta {:status "ok"}})
))

(run "List (Quoted) Literals Test" (fn []
  ; 意図: クォートされたリストが評価されずにデータ構造として構築されるか。
  (assert-eq '() '())
  (assert-eq '(1 2 3) '(1 2 3))
  (assert-eq '(+ 1 2) '(+ 1 2)) ; 式は評価されない
))

(run "Basic Operators Test" (fn []
  ; 意図: 算術、比較、論理演算子が期待通りに動作するか。
  ; 算術
  (assert-eq 5 (+ 2 3))
  (assert-eq -1 (- 2 3))
  (assert-eq 6 (* 2 3))
  (assert-eq 2 (/ 6 3))
  (assert-eq 1 (% 7 3))
  ; 比較
  (assert-eq true (= 5 5))
  (assert-eq false (= 5 4))
  (assert-eq true (!= 5 4))
  (assert-eq true (> 5 4))
  (assert-eq true (< 4 5))
  (assert-eq true (>= 5 5))
  (assert-eq true (<= 4 4))
  ; 論理
  (assert-eq true (and true true))
  (assert-eq false (and true false))
  (assert-eq true (or true false))
  (assert-eq false (or false false))
  (assert-eq false (not true))
  (assert-eq true (not false))
))

(run "Let Binding Test" (fn []
  ; 意図: letによるローカル変数の束縛、シャドーイング、分解束縛が機能するか。
  (let [x 10 y 20]
    (assert-eq 30 (+ x y)))
  (let [a 1]
    (let [a 2] ; シャドーイング
      (assert-eq 2 a))
    (assert-eq 1 a))
  ; 分解束縛
  (let [[x y] [10 20]]
    (assert-eq 30 (+ x y)))
  (let [{:name n :age a} {:name "Alice" :age 30}]
    (assert-eq "Alice is 30" f"{n} is {a}"))
  (let [[first ...rest] [1 2 3 4]]
    (assert-eq 1 first)
    (assert-eq '(2 3 4) rest))
))

(run "do Block Test" (fn []
  ; 意図: doブロックが式を順次実行し、最後の式の値を返すか。
  (let [a (atom 0)]
    (let [result (do
                   (swap! a inc)
                   (swap! a + 5)
                   (deref a))]
      (assert-eq 6 result)
      (assert-eq 6 (deref a)))
  )
))

; このファイルの最後にrun-allを置くことで、`qi test_syntax_and_data.qi` のように実行できる
; (test/run-all)
; ただし、`qi test` コマンドは自動でrun-allを呼ぶので、通常は不要。