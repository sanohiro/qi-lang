; math_torture_test.qi
; 数学関数（6個）の torture test
;
; math/pow, math/sqrt, math/round, math/floor, math/ceil, math/clamp

(println "========================================")
(println "数学関数 Torture Test 開始")
(println "========================================")

; ========================================
; Section 1: math/pow
; ========================================

(println "\n--- Section 1: math/pow ---")

; 1.1 基本動作
(println "\n[1.1] pow - 基本動作")
(def pow-basic-pass
  (and
    (= (math/pow 2 3) 8)
    (= (math/pow 10 2) 100)
    (= (math/pow 5 0) 1)
    (= (math/pow 3 1) 3)))

(if pow-basic-pass
  (println "✓ powの基本動作は正しく動作した")
  (println "✗ powの基本動作に問題がある"))

; 1.2 負の指数
(println "\n[1.2] pow - 負の指数")
(def pow-negative-pass
  (and
    (= (math/pow 2 -1) 0.5)
    (= (math/pow 10 -2) 0.01)))

(if pow-negative-pass
  (println "✓ powの負の指数は正しく動作した")
  (println "✗ powの負の指数に問題がある"))

; 1.3 大量データ
(println "\n[1.3] pow - 大量データ")
(def pow-bulk-pass
  (let [result (map (fn [x] (math/pow 2 x)) (range 0 10))]
    (and
      (= (len result) 10)
      (= (first result) 1)
      (= (last result) 512))))

(if pow-bulk-pass
  (println "✓ powの大量データ処理は正しく動作した")
  (println "✗ powの大量データ処理に問題がある"))

; ========================================
; Section 2: math/sqrt
; ========================================

(println "\n--- Section 2: math/sqrt ---")

; 2.1 基本動作
(println "\n[2.1] sqrt - 基本動作")
(def sqrt-basic-pass
  (and
    (= (math/sqrt 4) 2.0)
    (= (math/sqrt 9) 3.0)
    (= (math/sqrt 16) 4.0)
    (= (math/sqrt 1) 1.0)
    (= (math/sqrt 0) 0.0)))

(if sqrt-basic-pass
  (println "✓ sqrtの基本動作は正しく動作した")
  (println "✗ sqrtの基本動作に問題がある"))

; 2.2 小数
(println "\n[2.2] sqrt - 小数")
(def sqrt-float-pass
  (and
    (float? (math/sqrt 2))
    (float? (math/sqrt 3))
    (float? (math/sqrt 5))))

(if sqrt-float-pass
  (println "✓ sqrtの小数処理は正しく動作した")
  (println "✗ sqrtの小数処理に問題がある"))

; 2.3 大量データ
(println "\n[2.3] sqrt - 大量データ")
(def sqrt-bulk-pass
  (let [result (map math/sqrt (range 0 1000))]
    (and
      (= (len result) 1000)
      (= (first result) 0.0))))

(if sqrt-bulk-pass
  (println "✓ sqrtの大量データ処理は正しく動作した")
  (println "✗ sqrtの大量データ処理に問題がある"))

; ========================================
; Section 3: math/round
; ========================================

(println "\n--- Section 3: math/round ---")

; 3.1 基本動作
(println "\n[3.1] round - 基本動作")
(def round-basic-pass
  (and
    (= (math/round 3.4) 3)
    (= (math/round 3.5) 4)
    (= (math/round 3.6) 4)
    (= (math/round -3.4) -3)
    (= (math/round -3.5) -4)))

(if round-basic-pass
  (println "✓ roundの基本動作は正しく動作した")
  (println "✗ roundの基本動作に問題がある"))

; 3.2 整数
(println "\n[3.2] round - 整数")
(def round-int-pass
  (and
    (= (math/round 5) 5)
    (= (math/round 0) 0)
    (= (math/round -10) -10)))

(if round-int-pass
  (println "✓ roundの整数処理は正しく動作した")
  (println "✗ roundの整数処理に問題がある"))

; 3.3 大量データ
(println "\n[3.3] round - 大量データ")
(def round-bulk-pass
  (let [result (map math/round (range 0 1000))]
    (and
      (= (len result) 1000)
      (= (first result) 0)
      (= (last result) 999))))

(if round-bulk-pass
  (println "✓ roundの大量データ処理は正しく動作した")
  (println "✗ roundの大量データ処理に問題がある"))

; ========================================
; Section 4: math/floor
; ========================================

(println "\n--- Section 4: math/floor ---")

; 4.1 基本動作
(println "\n[4.1] floor - 基本動作")
(def floor-basic-pass
  (and
    (= (math/floor 3.1) 3)
    (= (math/floor 3.9) 3)
    (= (math/floor -3.1) -4)
    (= (math/floor -3.9) -4)))

(if floor-basic-pass
  (println "✓ floorの基本動作は正しく動作した")
  (println "✗ floorの基本動作に問題がある"))

; 4.2 整数
(println "\n[4.2] floor - 整数")
(def floor-int-pass
  (and
    (= (math/floor 5) 5)
    (= (math/floor 0) 0)
    (= (math/floor -10) -10)))

(if floor-int-pass
  (println "✓ floorの整数処理は正しく動作した")
  (println "✗ floorの整数処理に問題がある"))

; ========================================
; Section 5: math/ceil
; ========================================

(println "\n--- Section 5: math/ceil ---")

; 5.1 基本動作
(println "\n[5.1] ceil - 基本動作")
(def ceil-basic-pass
  (and
    (= (math/ceil 3.1) 4)
    (= (math/ceil 3.9) 4)
    (= (math/ceil -3.1) -3)
    (= (math/ceil -3.9) -3)))

(if ceil-basic-pass
  (println "✓ ceilの基本動作は正しく動作した")
  (println "✗ ceilの基本動作に問題がある"))

; 5.2 整数
(println "\n[5.2] ceil - 整数")
(def ceil-int-pass
  (and
    (= (math/ceil 5) 5)
    (= (math/ceil 0) 0)
    (= (math/ceil -10) -10)))

(if ceil-int-pass
  (println "✓ ceilの整数処理は正しく動作した")
  (println "✗ ceilの整数処理に問題がある"))

; ========================================
; Section 6: math/clamp
; ========================================

(println "\n--- Section 6: math/clamp ---")

; 6.1 基本動作
(println "\n[6.1] clamp - 基本動作")
(def clamp-basic-pass
  (and
    (= (math/clamp 5 0 10) 5)
    (= (math/clamp -5 0 10) 0)
    (= (math/clamp 15 0 10) 10)
    (= (math/clamp 0 0 10) 0)
    (= (math/clamp 10 0 10) 10)))

(if clamp-basic-pass
  (println "✓ clampの基本動作は正しく動作した")
  (println "✗ clampの基本動作に問題がある"))

; 6.2 負の範囲
(println "\n[6.2] clamp - 負の範囲")
(def clamp-negative-pass
  (and
    (= (math/clamp -7 -10 -5) -7)
    (= (math/clamp -15 -10 -5) -10)
    (= (math/clamp 0 -10 -5) -5)))

(if clamp-negative-pass
  (println "✓ clampの負の範囲は正しく動作した")
  (println "✗ clampの負の範囲に問題がある"))

; 6.3 大量データ
(println "\n[6.3] clamp - 大量データ")
(def clamp-bulk-pass
  (let [result (map (fn [x] (math/clamp x 0 100)) (range -50 151))]
    (and
      (= (len result) 201)
      (= (first result) 0)
      (= (last result) 100))))

(if clamp-bulk-pass
  (println "✓ clampの大量データ処理は正しく動作した")
  (println "✗ clampの大量データ処理に問題がある"))

; ========================================
; Section 7: 統合テスト
; ========================================

(println "\n--- Section 7: 統合テスト ---")

; 7.1 組み合わせ
(println "\n[7.1] 数学関数の組み合わせ")
(def integration-pass
  (and
    (= (math/round (math/sqrt 16)) 4)
    (= (math/floor (math/pow 2 3.5)) 11)
    (= (math/ceil (math/sqrt 10)) 4)
    (= (math/clamp (math/round 12.7) 0 10) 10)))

(if integration-pass
  (println "✓ 数学関数の組み合わせは正しく動作した")
  (println "✗ 数学関数の組み合わせに問題がある"))

; 7.2 パイプライン
(println "\n[7.2] パイプラインでの使用")
(def pipeline-pass
  (= (16.5 |> math/sqrt |> math/round) 4))

(if pipeline-pass
  (println "✓ パイプライン使用は正しく動作した")
  (println "✗ パイプライン使用に問題がある"))

; ========================================
; Section 8: 高負荷テスト
; ========================================

(println "\n--- Section 8: 高負荷テスト ---")

; 8.1 大量の計算
(println "\n[8.1] 大量の計算")
(def bulk-pass
  (let [squares (map (fn [x] (math/pow x 2)) (range 1 101))
        roots (map math/sqrt squares)
        rounded (map math/round roots)]
    (and
      (= (len rounded) 100)
      (= (first rounded) 1)
      (= (last rounded) 100))))

(if bulk-pass
  (println "✓ 大量の計算は正しく動作した")
  (println "✗ 大量の計算に問題がある"))

; 8.2 並列処理
(println "\n[8.2] 並列処理")
(def parallel-pass
  (let [result (pmap (fn [x] (math/clamp (math/round (math/sqrt x)) 0 100)) (range 0 1000))]
    (and
      (= (len result) 1000)
      (= (first result) 0))))

(if parallel-pass
  (println "✓ 並列処理は正しく動作した")
  (println "✗ 並列処理に問題がある"))

; ========================================
; 最終結果
; ========================================

(println "\n========================================")
(println "数学関数 Torture Test 完了")
(println "========================================")
(println "\n全セクションが実行されました。")
(println "各セクションのチェックマーク (✓/✗) を確認してください。")
