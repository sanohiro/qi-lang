; set_torture_test.qi
; 集合操作関数（7個）の torture test
;
; set/union, set/intersect, set/difference,
; set/subset?, set/superset?, set/disjoint?, set/symmetric-difference

(println "========================================")
(println "集合操作関数 Torture Test 開始")
(println "========================================")

; ========================================
; Section 1: set/union
; ========================================

(println "\n--- Section 1: set/union ---")

; 1.1 基本動作
(println "\n[1.1] union - 基本動作")
(def union-basic-pass
  (let [result (set/union [1 2 3] [3 4 5])]
    (= (len result) 5)))

(if union-basic-pass
  (println "✓ unionの基本動作は正しく動作した")
  (println "✗ unionの基本動作に問題がある"))

; 1.2 空リスト
(println "\n[1.2] union - 空リスト")
(def union-empty-pass
  (and
    (= (len (set/union [] [])) 0)
    (= (len (set/union [1 2] [])) 2)
    (= (len (set/union [] [1 2])) 2)))

(if union-empty-pass
  (println "✓ unionの空リストは正しく動作した")
  (println "✗ unionの空リストに問題がある"))

; 1.3 重複排除
(println "\n[1.3] union - 重複排除")
(def union-dup-pass
  (let [result (set/union [1 1 2 2] [2 2 3 3])]
    (= (len result) 3)))

(if union-dup-pass
  (println "✓ unionの重複排除は正しく動作した")
  (println "✗ unionの重複排除に問題がある"))

; 1.4 複数リスト
(println "\n[1.4] union - 複数リスト")
(def union-multi-pass
  (let [result (set/union [1 2] [3 4] [5 6])]
    (= (len result) 6)))

(if union-multi-pass
  (println "✓ unionの複数リストは正しく動作した")
  (println "✗ unionの複数リストに問題がある"))

; 1.5 大量データ
(println "\n[1.5] union - 大量データ")
(def union-bulk-pass
  (let [set1 (range 0 5000)
        set2 (range 4000 9000)
        result (set/union set1 set2)]
    (= (len result) 9000)))

(if union-bulk-pass
  (println "✓ unionの大量データ処理は正しく動作した")
  (println "✗ unionの大量データ処理に問題がある"))

; ========================================
; Section 2: set/intersect
; ========================================

(println "\n--- Section 2: set/intersect ---")

; 2.1 基本動作
(println "\n[2.1] intersect - 基本動作")
(def intersect-basic-pass
  (let [result (set/intersect [1 2 3 4] [3 4 5 6])]
    (= (len result) 2)))

(if intersect-basic-pass
  (println "✓ intersectの基本動作は正しく動作した")
  (println "✗ intersectの基本動作に問題がある"))

; 2.2 共通要素なし
(println "\n[2.2] intersect - 共通要素なし")
(def intersect-empty-pass
  (let [result (set/intersect [1 2 3] [4 5 6])]
    (= (len result) 0)))

(if intersect-empty-pass
  (println "✓ intersectの共通要素なしは正しく動作した")
  (println "✗ intersectの共通要素なしに問題がある"))

; 2.3 完全一致
(println "\n[2.3] intersect - 完全一致")
(def intersect-full-pass
  (let [result (set/intersect [1 2 3] [1 2 3])]
    (= (len result) 3)))

(if intersect-full-pass
  (println "✓ intersectの完全一致は正しく動作した")
  (println "✗ intersectの完全一致に問題がある"))

; 2.4 複数リスト
(println "\n[2.4] intersect - 複数リスト")
(def intersect-multi-pass
  (let [result (set/intersect [1 2 3 4 5] [2 3 4 5 6] [3 4 5 6 7])]
    (= (len result) 3)))

(if intersect-multi-pass
  (println "✓ intersectの複数リストは正しく動作した")
  (println "✗ intersectの複数リストに問題がある"))

; 2.5 大量データ
(println "\n[2.5] intersect - 大量データ")
(def intersect-bulk-pass
  (let [set1 (range 0 10000)
        set2 (range 5000 15000)
        result (set/intersect set1 set2)]
    (= (len result) 5000)))

(if intersect-bulk-pass
  (println "✓ intersectの大量データ処理は正しく動作した")
  (println "✗ intersectの大量データ処理に問題がある"))

; ========================================
; Section 3: set/difference
; ========================================

(println "\n--- Section 3: set/difference ---")

; 3.1 基本動作
(println "\n[3.1] difference - 基本動作")
(def diff-basic-pass
  (let [result (set/difference [1 2 3 4 5] [3 4 5 6 7])]
    (= (len result) 2)))

(if diff-basic-pass
  (println "✓ differenceの基本動作は正しく動作した")
  (println "✗ differenceの基本動作に問題がある"))

; 3.2 完全除去
(println "\n[3.2] difference - 完全除去")
(def diff-empty-pass
  (let [result (set/difference [1 2 3] [1 2 3 4 5])]
    (= (len result) 0)))

(if diff-empty-pass
  (println "✓ differenceの完全除去は正しく動作した")
  (println "✗ differenceの完全除去に問題がある"))

; 3.3 除去なし
(println "\n[3.3] difference - 除去なし")
(def diff-none-pass
  (let [result (set/difference [1 2 3] [4 5 6])]
    (= (len result) 3)))

(if diff-none-pass
  (println "✓ differenceの除去なしは正しく動作した")
  (println "✗ differenceの除去なしに問題がある"))

; 3.4 複数リスト
(println "\n[3.4] difference - 複数リスト")
(def diff-multi-pass
  (let [result (set/difference [1 2 3 4 5 6] [2 3] [4 5])]
    (= (len result) 2)))

(if diff-multi-pass
  (println "✓ differenceの複数リストは正しく動作した")
  (println "✗ differenceの複数リストに問題がある"))

; 3.5 大量データ
(println "\n[3.5] difference - 大量データ")
(def diff-bulk-pass
  (let [set1 (range 0 10000)
        set2 (range 5000 15000)
        result (set/difference set1 set2)]
    (= (len result) 5000)))

(if diff-bulk-pass
  (println "✓ differenceの大量データ処理は正しく動作した")
  (println "✗ differenceの大量データ処理に問題がある"))

; ========================================
; Section 4: set/subset?
; ========================================

(println "\n--- Section 4: set/subset? ---")

; 4.1 基本動作
(println "\n[4.1] subset? - 基本動作")
(def subset-basic-pass
  (and
    (set/subset? [1 2] [1 2 3 4])
    (set/subset? [1 2 3] [1 2 3])
    (not (set/subset? [1 2 5] [1 2 3 4]))))

(if subset-basic-pass
  (println "✓ subset?の基本動作は正しく動作した")
  (println "✗ subset?の基本動作に問題がある"))

; 4.2 空集合
(println "\n[4.2] subset? - 空集合")
(def subset-empty-pass
  (and
    (set/subset? [] [1 2 3])
    (set/subset? [] [])))

(if subset-empty-pass
  (println "✓ subset?の空集合は正しく動作した")
  (println "✗ subset?の空集合に問題がある"))

; 4.3 大量データ
(println "\n[4.3] subset? - 大量データ")
(def subset-bulk-pass
  (let [small (range 0 1000)
        large (range 0 10000)]
    (set/subset? small large)))

(if subset-bulk-pass
  (println "✓ subset?の大量データ処理は正しく動作した")
  (println "✗ subset?の大量データ処理に問題がある"))

; ========================================
; Section 5: set/superset?
; ========================================

(println "\n--- Section 5: set/superset? ---")

; 5.1 基本動作
(println "\n[5.1] superset? - 基本動作")
(def superset-basic-pass
  (and
    (set/superset? [1 2 3 4] [1 2])
    (set/superset? [1 2 3] [1 2 3])
    (not (set/superset? [1 2 3 4] [1 2 5]))))

(if superset-basic-pass
  (println "✓ superset?の基本動作は正しく動作した")
  (println "✗ superset?の基本動作に問題がある"))

; 5.2 空集合
(println "\n[5.2] superset? - 空集合")
(def superset-empty-pass
  (and
    (set/superset? [1 2 3] [])
    (set/superset? [] [])))

(if superset-empty-pass
  (println "✓ superset?の空集合は正しく動作した")
  (println "✗ superset?の空集合に問題がある"))

; 5.3 大量データ
(println "\n[5.3] superset? - 大量データ")
(def superset-bulk-pass
  (let [small (range 0 1000)
        large (range 0 10000)]
    (set/superset? large small)))

(if superset-bulk-pass
  (println "✓ superset?の大量データ処理は正しく動作した")
  (println "✗ superset?の大量データ処理に問題がある"))

; ========================================
; Section 6: set/disjoint?
; ========================================

(println "\n--- Section 6: set/disjoint? ---")

; 6.1 基本動作
(println "\n[6.1] disjoint? - 基本動作")
(def disjoint-basic-pass
  (and
    (set/disjoint? [1 2 3] [4 5 6])
    (not (set/disjoint? [1 2 3] [3 4 5]))
    (not (set/disjoint? [1 2 3] [1 2 3]))))

(if disjoint-basic-pass
  (println "✓ disjoint?の基本動作は正しく動作した")
  (println "✗ disjoint?の基本動作に問題がある"))

; 6.2 空集合
(println "\n[6.2] disjoint? - 空集合")
(def disjoint-empty-pass
  (and
    (set/disjoint? [] [1 2 3])
    (set/disjoint? [1 2 3] [])
    (set/disjoint? [] [])))

(if disjoint-empty-pass
  (println "✓ disjoint?の空集合は正しく動作した")
  (println "✗ disjoint?の空集合に問題がある"))

; 6.3 大量データ
(println "\n[6.3] disjoint? - 大量データ")
(def disjoint-bulk-pass
  (let [set1 (range 0 5000)
        set2 (range 5000 10000)]
    (set/disjoint? set1 set2)))

(if disjoint-bulk-pass
  (println "✓ disjoint?の大量データ処理は正しく動作した")
  (println "✗ disjoint?の大量データ処理に問題がある"))

; ========================================
; Section 7: set/symmetric-difference
; ========================================

(println "\n--- Section 7: set/symmetric-difference ---")

; 7.1 基本動作
(println "\n[7.1] symmetric-difference - 基本動作")
(def symdiff-basic-pass
  (let [result (set/symmetric-difference [1 2 3 4] [3 4 5 6])]
    (= (len result) 4)))

(if symdiff-basic-pass
  (println "✓ symmetric-differenceの基本動作は正しく動作した")
  (println "✗ symmetric-differenceの基本動作に問題がある"))

; 7.2 完全一致
(println "\n[7.2] symmetric-difference - 完全一致")
(def symdiff-empty-pass
  (let [result (set/symmetric-difference [1 2 3] [1 2 3])]
    (= (len result) 0)))

(if symdiff-empty-pass
  (println "✓ symmetric-differenceの完全一致は正しく動作した")
  (println "✗ symmetric-differenceの完全一致に問題がある"))

; 7.3 完全不一致
(println "\n[7.3] symmetric-difference - 完全不一致")
(def symdiff-full-pass
  (let [result (set/symmetric-difference [1 2 3] [4 5 6])]
    (= (len result) 6)))

(if symdiff-full-pass
  (println "✓ symmetric-differenceの完全不一致は正しく動作した")
  (println "✗ symmetric-differenceの完全不一致に問題がある"))

; 7.4 大量データ
(println "\n[7.4] symmetric-difference - 大量データ")
(def symdiff-bulk-pass
  (let [set1 (range 0 10000)
        set2 (range 5000 15000)
        result (set/symmetric-difference set1 set2)]
    (= (len result) 10000)))

(if symdiff-bulk-pass
  (println "✓ symmetric-differenceの大量データ処理は正しく動作した")
  (println "✗ symmetric-differenceの大量データ処理に問題がある"))

; ========================================
; Section 8: 統合テスト
; ========================================

(println "\n--- Section 8: 統合テスト ---")

; 8.1 複数関数の組み合わせ
(println "\n[8.1] 複数関数の組み合わせ")
(def integration-pass
  (let [set1 [1 2 3 4 5]
        set2 [4 5 6 7 8]
        union (set/union set1 set2)
        intersect (set/intersect set1 set2)
        diff (set/difference set1 set2)]
    (and
      (= (len union) 8)
      (= (len intersect) 2)
      (= (len diff) 3))))

(if integration-pass
  (println "✓ 複数関数の組み合わせは正しく動作した")
  (println "✗ 複数関数の組み合わせに問題がある"))

; 8.2 述語の組み合わせ
(println "\n[8.2] 述語の組み合わせ")
(def predicate-pass
  (let [set1 [1 2]
        set2 [1 2 3 4]
        set3 [5 6]]
    (and
      (set/subset? set1 set2)
      (set/superset? set2 set1)
      (set/disjoint? set1 set3))))

(if predicate-pass
  (println "✓ 述語の組み合わせは正しく動作した")
  (println "✗ 述語の組み合わせに問題がある"))

; ========================================
; Section 9: 高負荷テスト
; ========================================

(println "\n--- Section 9: 高負荷テスト ---")

; 9.1 大量データでの統合
(println "\n[9.1] 大量データでの統合")
(def bulk-integration-pass
  (let [set1 (range 0 10000)
        set2 (range 5000 15000)
        union (set/union set1 set2)
        intersect (set/intersect set1 set2)
        diff (set/difference set1 set2)]
    (and
      (= (len union) 15000)
      (= (len intersect) 5000)
      (= (len diff) 5000))))

(if bulk-integration-pass
  (println "✓ 大量データでの統合は正しく動作した")
  (println "✗ 大量データでの統合に問題がある"))

; 9.2 並列処理
(println "\n[9.2] 並列処理")
(def parallel-pass
  (let [sets (map (fn [x] (range x (+ x 100))) (range 0 100))
        results (pmap (fn [s] (set/union s [99 100 101])) sets)]
    (= (len results) 100)))

(if parallel-pass
  (println "✓ 並列処理は正しく動作した")
  (println "✗ 並列処理に問題がある"))

; ========================================
; 最終結果
; ========================================

(println "\n========================================")
(println "集合操作関数 Torture Test 完了")
(println "========================================")
(println "\n全セクションが実行されました。")
(println "各セクションのチェックマーク (✓/✗) を確認してください。")
