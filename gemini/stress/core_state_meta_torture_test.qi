; core_state_meta_torture_test.qi
; Core状態管理・メタプログラミング関数（6個）の torture test
;
; 状態管理(3): atom, deref, reset!
; メタ(3): uvar, variable, macro?

(println "========================================")
(println "Core状態管理・メタ Torture Test 開始")
(println "========================================")

; ========================================
; Section 1: atom
; ========================================

(println "\n--- Section 1: atom ---")

; 1.1 基本的な動作
(println "\n[1.1] atom - 基本動作")
(def a1 (atom 0))
(def a2 (atom "hello"))
(def a3 (atom [1 2 3]))
(def atom-basic-pass
  (and
    (atom? a1)
    (atom? a2)
    (atom? a3)
    (not (atom? 42))
    (not (atom? "test"))))

(if atom-basic-pass
  (println "✓ atomの基本動作は正しく動作した")
  (println "✗ atomの基本動作に問題がある"))

; 1.2 様々な型の保持
(println "\n[1.2] atom - 様々な型")
(def atom-types-pass
  (and
    (atom? (atom nil))
    (atom? (atom true))
    (atom? (atom 42))
    (atom? (atom 3.14))
    (atom? (atom "string"))
    (atom? (atom :keyword))
    (atom? (atom '(1 2 3)))
    (atom? (atom {:a 1}))))

(if atom-types-pass
  (println "✓ atomの様々な型保持は正しく動作した")
  (println "✗ atomの様々な型保持に問題がある"))

; 1.3 ネストされたデータ構造
(println "\n[1.3] atom - ネストされたデータ")
(def complex-atom (atom {:users [{:name "Alice"} {:name "Bob"}] :count 2}))
(def atom-complex-pass
  (atom? complex-atom))

(if atom-complex-pass
  (println "✓ atomのネストされたデータ構造は正しく動作した")
  (println "✗ atomのネストされたデータ構造に問題がある"))

; ========================================
; Section 2: deref
; ========================================

(println "\n--- Section 2: deref ---")

; 2.1 基本的な動作
(println "\n[2.1] deref - 基本動作")
(def counter (atom 0))
(def name-atom (atom "test"))
(def deref-basic-pass
  (and
    (= (deref counter) 0)
    (= (deref name-atom) "test")
    (= (deref (atom [1 2 3])) [1 2 3])))

(if deref-basic-pass
  (println "✓ derefの基本動作は正しく動作した")
  (println "✗ derefの基本動作に問題がある"))

; 2.2 様々な型の取得
(println "\n[2.2] deref - 様々な型")
(def deref-types-pass
  (and
    (= (deref (atom nil)) nil)
    (= (deref (atom true)) true)
    (= (deref (atom 42)) 42)
    (= (deref (atom 3.14)) 3.14)
    (= (deref (atom "hello")) "hello")
    (= (deref (atom :keyword)) :keyword)))

(if deref-types-pass
  (println "✓ derefの様々な型取得は正しく動作した")
  (println "✗ derefの様々な型取得に問題がある"))

; 2.3 複雑なデータの取得
(println "\n[2.3] deref - 複雑なデータ")
(def data-atom (atom {:x 10 :y 20 :nested {:z 30}}))
(def deref-complex-pass
  (let [data (deref data-atom)]
    (and
      (map? data)
      (= (len (keys data)) 3))))

(if deref-complex-pass
  (println "✓ derefの複雑なデータ取得は正しく動作した")
  (println "✗ derefの複雑なデータ取得に問題がある"))

; ========================================
; Section 3: reset!
; ========================================

(println "\n--- Section 3: reset! ---")

; 3.1 基本的な動作
(println "\n[3.1] reset! - 基本動作")
(def counter-reset (atom 0))
(def reset-basic-pass
  (and
    (= (reset! counter-reset 10) 10)
    (= (deref counter-reset) 10)
    (= (reset! counter-reset 20) 20)
    (= (deref counter-reset) 20)))

(if reset-basic-pass
  (println "✓ reset!の基本動作は正しく動作した")
  (println "✗ reset!の基本動作に問題がある"))

; 3.2 様々な型の設定
(println "\n[3.2] reset! - 様々な型")
(def multi-atom (atom 0))
(def reset-types-pass
  (and
    (= (reset! multi-atom "hello") "hello")
    (= (deref multi-atom) "hello")
    (= (reset! multi-atom [1 2 3]) [1 2 3])
    (= (deref multi-atom) [1 2 3])
    (= (reset! multi-atom {:a 1}) {:a 1})
    (= (deref multi-atom) {:a 1})))

(if reset-types-pass
  (println "✓ reset!の様々な型設定は正しく動作した")
  (println "✗ reset!の様々な型設定に問題がある"))

; 3.3 複数回の更新
(println "\n[3.3] reset! - 複数回更新")
(def counter-multi (atom 0))
(def reset-multi-pass
  (do
    (reset! counter-multi 1)
    (reset! counter-multi 2)
    (reset! counter-multi 3)
    (= (deref counter-multi) 3)))

(if reset-multi-pass
  (println "✓ reset!の複数回更新は正しく動作した")
  (println "✗ reset!の複数回更新に問題がある"))

; ========================================
; Section 4: uvar
; ========================================

(println "\n--- Section 4: uvar ---")

; 4.1 基本的な動作
(println "\n[4.1] uvar - 基本動作")
(def u1 (uvar))
(def u2 (uvar))
(def uvar-basic-pass
  (and
    (some? u1)
    (some? u2)
    (not (= u1 u2))))

(if uvar-basic-pass
  (println "✓ uvarの基本動作は正しく動作した")
  (println "✗ uvarの基本動作に問題がある"))

; 4.2 一意性の確認
(println "\n[4.2] uvar - 一意性")
(def uvars (map (fn [_] (uvar)) (range 0 100)))
(def uvar-unique-pass
  (= (len uvars) (len (list/dedupe uvars))))

(if uvar-unique-pass
  (println "✓ uvarの一意性は正しく動作した")
  (println "✗ uvarの一意性に問題がある"))

; 4.3 大量生成
(println "\n[4.3] uvar - 大量生成")
(def uvar-bulk-pass
  (let [uvars-bulk (map (fn [_] (uvar)) (range 0 10000))]
    (= (len uvars-bulk) 10000)))

(if uvar-bulk-pass
  (println "✓ uvarの大量生成は正しく動作した")
  (println "✗ uvarの大量生成に問題がある"))

; ========================================
; Section 5: variable
; ========================================

(println "\n--- Section 5: variable ---")

; 5.1 基本的な動作
(println "\n[5.1] variable - 基本動作")
(def v1 (uvar))
(def variable-basic-pass
  (and
    (variable v1)
    (not (variable 42))
    (not (variable "string"))
    (not (variable :keyword))
    (not (variable [1 2 3]))
    (not (variable {:a 1}))))

(if variable-basic-pass
  (println "✓ variableの基本動作は正しく動作した")
  (println "✗ variableの基本動作に問題がある"))

; 5.2 nilとboolの扱い
(println "\n[5.2] variable - 特殊値")
(def variable-special-pass
  (and
    (not (variable nil))
    (not (variable true))
    (not (variable false))))

(if variable-special-pass
  (println "✓ variableの特殊値扱いは正しく動作した")
  (println "✗ variableの特殊値扱いに問題がある"))

; 5.3 filterでの使用
(println "\n[5.3] variable - filterで使用")
(def mixed-data [1 "test" (uvar) (uvar) :keyword nil])
(def variable-filter-pass
  (let [vars (filter variable mixed-data)]
    (= (len vars) 2)))

(if variable-filter-pass
  (println "✓ variableのfilter使用は正しく動作した")
  (println "✗ variableのfilter使用に問題がある"))

; ========================================
; Section 6: macro?
; ========================================

(println "\n--- Section 6: macro? ---")

; 6.1 基本的な動作
(println "\n[6.1] macro? - 基本動作")
(def macro-basic-pass
  (and
    (not (macro? 42))
    (not (macro? "string"))
    (not (macro? (fn [] 1)))
    (not (macro? [1 2 3]))
    (not (macro? {:a 1}))))

(if macro-basic-pass
  (println "✓ macro?の基本動作は正しく動作した")
  (println "✗ macro?の基本動作に問題がある"))

; 6.2 様々な型のチェック
(println "\n[6.2] macro? - 様々な型")
(def macro-types-pass
  (and
    (not (macro? nil))
    (not (macro? true))
    (not (macro? false))
    (not (macro? :keyword))
    (not (macro? (atom 0)))
    (not (macro? (uvar)))))

(if macro-types-pass
  (println "✓ macro?の様々な型チェックは正しく動作した")
  (println "✗ macro?の様々な型チェックに問題がある"))

; ========================================
; Section 7: 統合テスト
; ========================================

(println "\n--- Section 7: 統合テスト ---")

; 7.1 atomとderef/reset!の組み合わせ
(println "\n[7.1] atom + deref + reset!")
(def state (atom {:count 0 :name "test"}))
(def integration-pass
  (and
    (map? (deref state))
    (= (reset! state {:count 10 :name "updated"}) {:count 10 :name "updated"})
    (map? (deref state))))

(if integration-pass
  (println "✓ atom/deref/reset!の統合は正しく動作した")
  (println "✗ atom/deref/reset!の統合に問題がある"))

; 7.2 uvarとvariableの組み合わせ
(println "\n[7.2] uvar + variable")
(def uvar-integration-pass
  (let [v (uvar)]
    (and
      (variable v)
      (some? v))))

(if uvar-integration-pass
  (println "✓ uvar/variableの統合は正しく動作した")
  (println "✗ uvar/variableの統合に問題がある"))

; 7.3 パイプラインでの使用
(println "\n[7.3] パイプラインでの使用")
(def pipeline-pass
  (let [result ((atom 10) |> deref)]
    (= result 10)))

(if pipeline-pass
  (println "✓ パイプライン使用は正しく動作した")
  (println "✗ パイプライン使用に問題がある"))

; ========================================
; Section 8: 高負荷テスト
; ========================================

(println "\n--- Section 8: 高負荷テスト ---")

; 8.1 大量のatom生成
(println "\n[8.1] 大量のatom生成")
(def atoms (map atom (range 0 1000)))
(def bulk-atom-pass
  (and
    (= (len atoms) 1000)
    (list/every? atom? atoms)))

(if bulk-atom-pass
  (println "✓ 大量のatom生成は正しく動作した")
  (println "✗ 大量のatom生成に問題がある"))

; 8.2 大量のreset!操作
(println "\n[8.2] 大量のreset!操作")
(def counter-bulk (atom 0))
(def bulk-reset-pass
  (do
    (map (fn [i] (reset! counter-bulk i)) (range 0 1000))
    (= (deref counter-bulk) 999)))

(if bulk-reset-pass
  (println "✓ 大量のreset!操作は正しく動作した")
  (println "✗ 大量のreset!操作に問題がある"))

; 8.3 並列でのuvar生成
(println "\n[8.3] 並列でのuvar生成")
(def parallel-uvar-pass
  (let [uvars-parallel (pmap (fn [_] (uvar)) (range 0 1000))]
    (and
      (= (len uvars-parallel) 1000)
      (= (len uvars-parallel) (len (list/dedupe uvars-parallel))))))

(if parallel-uvar-pass
  (println "✓ 並列でのuvar生成は正しく動作した")
  (println "✗ 並列でのuvar生成に問題がある"))

; ========================================
; 最終結果
; ========================================

(println "\n========================================")
(println "Core状態管理・メタ Torture Test 完了")
(println "========================================")
(println "\n全セクションが実行されました。")
(println "各セクションのチェックマーク (✓/✗) を確認してください。")
