; queue_stack_torture_test.qi
; Queue/Stack関数（12個）の torture test
;
; Queue: queue/new, queue/enqueue, queue/dequeue, queue/peek, queue/empty?, queue/size (6個)
; Stack: stack/new, stack/push, stack/pop, stack/peek, stack/empty?, stack/size (6個)

(println "========================================")
(println "Queue/Stack関数 Torture Test 開始")
(println "========================================")

; ========================================
; Section 1: queue/new
; ========================================

(println "\n--- Section 1: queue/new ---")

; 1.1 基本動作
(println "\n[1.1] queue/new - 基本動作")
(def queue-new-pass
  (let [q (queue/new)]
    (and
      (map? q)
      (= (get q :type) :queue)
      (queue/empty? q))))

(if queue-new-pass
  (println "✓ queue/newの基本動作は正しく動作した")
  (println "✗ queue/newの基本動作に問題がある"))

; ========================================
; Section 2: queue/enqueue
; ========================================

(println "\n--- Section 2: queue/enqueue ---")

; 2.1 基本動作
(println "\n[2.1] queue/enqueue - 基本動作")
(def queue-enqueue-basic-pass
  (let [q (queue/new)
        q1 (queue/enqueue q 1)
        q2 (queue/enqueue q1 2)
        q3 (queue/enqueue q2 3)]
    (and
      (= (queue/size q1) 1)
      (= (queue/size q2) 2)
      (= (queue/size q3) 3))))

(if queue-enqueue-basic-pass
  (println "✓ queue/enqueueの基本動作は正しく動作した")
  (println "✗ queue/enqueueの基本動作に問題がある"))

; 2.2 様々な型
(println "\n[2.2] queue/enqueue - 様々な型")
(def queue-enqueue-types-pass
  (let [q (queue/new)
        q1 (queue/enqueue q 42)
        q2 (queue/enqueue q1 3.14)
        q3 (queue/enqueue q2 "hello")
        q4 (queue/enqueue q3 true)
        q5 (queue/enqueue q4 nil)
        q6 (queue/enqueue q5 [1 2 3])]
    (= (queue/size q6) 6)))

(if queue-enqueue-types-pass
  (println "✓ queue/enqueueの様々な型は正しく動作した")
  (println "✗ queue/enqueueの様々な型に問題がある"))

; 2.3 大量データ
(println "\n[2.3] queue/enqueue - 大量データ")
(def queue-enqueue-bulk-pass
  (let [q (reduce (fn [acc i] (queue/enqueue acc i))
                  (queue/new)
                  (range 0 1000))]
    (= (queue/size q) 1000)))

(if queue-enqueue-bulk-pass
  (println "✓ queue/enqueueの大量データ処理は正しく動作した")
  (println "✗ queue/enqueueの大量データ処理に問題がある"))

; ========================================
; Section 3: queue/dequeue
; ========================================

(println "\n--- Section 3: queue/dequeue ---")

; 3.1 基本動作（FIFO確認）
(println "\n[3.1] queue/dequeue - 基本動作（FIFO）")
(def queue-dequeue-basic-pass
  (let [q (queue/new)
        q1 (queue/enqueue q 1)
        q2 (queue/enqueue q1 2)
        q3 (queue/enqueue q2 3)
        result1 (queue/dequeue q3)
        result2 (queue/dequeue (get result1 :queue))
        result3 (queue/dequeue (get result2 :queue))]
    (and
      (= (get result1 :value) 1)
      (= (get result2 :value) 2)
      (= (get result3 :value) 3))))

(if queue-dequeue-basic-pass
  (println "✓ queue/dequeueのFIFO動作は正しく動作した")
  (println "✗ queue/dequeueのFIFO動作に問題がある"))

; 3.2 dequeueとsize
(println "\n[3.2] queue/dequeue - サイズ変化")
(def queue-dequeue-size-pass
  (let [q (queue/new)
        q1 (queue/enqueue q 1)
        q2 (queue/enqueue q1 2)
        q3 (queue/enqueue q2 3)
        result1 (queue/dequeue q3)
        new-q (get result1 :queue)]
    (= (queue/size new-q) 2)))

(if queue-dequeue-size-pass
  (println "✓ queue/dequeueのサイズ変化は正しく動作した")
  (println "✗ queue/dequeueのサイズ変化に問題がある"))

; 3.3 大量データのdequeue
(println "\n[3.3] queue/dequeue - 大量データ")
(def queue-dequeue-bulk-pass
  (let [q (reduce (fn [acc i] (queue/enqueue acc i))
                  (queue/new)
                  (range 0 100))
        ; 最初の10個をdequeue
        final-q (reduce (fn [acc _]
                         (let [result (queue/dequeue acc)]
                           (get result :queue)))
                       q
                       (range 0 10))]
    (= (queue/size final-q) 90)))

(if queue-dequeue-bulk-pass
  (println "✓ queue/dequeueの大量データ処理は正しく動作した")
  (println "✗ queue/dequeueの大量データ処理に問題がある"))

; ========================================
; Section 4: queue/peek
; ========================================

(println "\n--- Section 4: queue/peek ---")

; 4.1 基本動作（非破壊）
(println "\n[4.1] queue/peek - 基本動作（非破壊）")
(def queue-peek-pass
  (let [q (queue/new)
        q1 (queue/enqueue q 1)
        q2 (queue/enqueue q1 2)
        val (queue/peek q2)]
    (and
      (= val 1)
      (= (queue/size q2) 2))))

(if queue-peek-pass
  (println "✓ queue/peekの非破壊動作は正しく動作した")
  (println "✗ queue/peekの非破壊動作に問題がある"))

; 4.2 複数回peek
(println "\n[4.2] queue/peek - 複数回peek")
(def queue-peek-multiple-pass
  (let [q (queue/enqueue (queue/new) 42)
        val1 (queue/peek q)
        val2 (queue/peek q)
        val3 (queue/peek q)]
    (and
      (= val1 42)
      (= val2 42)
      (= val3 42))))

(if queue-peek-multiple-pass
  (println "✓ queue/peekの複数回実行は正しく動作した")
  (println "✗ queue/peekの複数回実行に問題がある"))

; ========================================
; Section 5: queue/empty?
; ========================================

(println "\n--- Section 5: queue/empty? ---")

; 5.1 基本動作
(println "\n[5.1] queue/empty? - 基本動作")
(def queue-empty-pass
  (let [q (queue/new)
        q1 (queue/enqueue q 1)
        result1 (queue/dequeue q1)
        q2 (get result1 :queue)]
    (and
      (queue/empty? q)
      (not (queue/empty? q1))
      (queue/empty? q2))))

(if queue-empty-pass
  (println "✓ queue/empty?は正しく動作した")
  (println "✗ queue/empty?に問題がある"))

; ========================================
; Section 6: queue/size
; ========================================

(println "\n--- Section 6: queue/size ---")

; 6.1 基本動作
(println "\n[6.1] queue/size - 基本動作")
(def queue-size-pass
  (let [q (queue/new)
        q1 (queue/enqueue q 1)
        q2 (queue/enqueue q1 2)
        q3 (queue/enqueue q2 3)]
    (and
      (= (queue/size q) 0)
      (= (queue/size q1) 1)
      (= (queue/size q2) 2)
      (= (queue/size q3) 3))))

(if queue-size-pass
  (println "✓ queue/sizeは正しく動作した")
  (println "✗ queue/sizeに問題がある"))

; ========================================
; Section 7: stack/new
; ========================================

(println "\n--- Section 7: stack/new ---")

; 7.1 基本動作
(println "\n[7.1] stack/new - 基本動作")
(def stack-new-pass
  (let [s (stack/new)]
    (and
      (map? s)
      (= (get s :type) :stack)
      (stack/empty? s))))

(if stack-new-pass
  (println "✓ stack/newの基本動作は正しく動作した")
  (println "✗ stack/newの基本動作に問題がある"))

; ========================================
; Section 8: stack/push
; ========================================

(println "\n--- Section 8: stack/push ---")

; 8.1 基本動作
(println "\n[8.1] stack/push - 基本動作")
(def stack-push-basic-pass
  (let [s (stack/new)
        s1 (stack/push s 1)
        s2 (stack/push s1 2)
        s3 (stack/push s2 3)]
    (and
      (= (stack/size s1) 1)
      (= (stack/size s2) 2)
      (= (stack/size s3) 3))))

(if stack-push-basic-pass
  (println "✓ stack/pushの基本動作は正しく動作した")
  (println "✗ stack/pushの基本動作に問題がある"))

; 8.2 様々な型
(println "\n[8.2] stack/push - 様々な型")
(def stack-push-types-pass
  (let [s (stack/new)
        s1 (stack/push s 42)
        s2 (stack/push s1 3.14)
        s3 (stack/push s2 "hello")
        s4 (stack/push s3 true)
        s5 (stack/push s4 nil)
        s6 (stack/push s5 [1 2 3])]
    (= (stack/size s6) 6)))

(if stack-push-types-pass
  (println "✓ stack/pushの様々な型は正しく動作した")
  (println "✗ stack/pushの様々な型に問題がある"))

; 8.3 大量データ
(println "\n[8.3] stack/push - 大量データ")
(def stack-push-bulk-pass
  (let [s (reduce (fn [acc i] (stack/push acc i))
                  (stack/new)
                  (range 0 1000))]
    (= (stack/size s) 1000)))

(if stack-push-bulk-pass
  (println "✓ stack/pushの大量データ処理は正しく動作した")
  (println "✗ stack/pushの大量データ処理に問題がある"))

; ========================================
; Section 9: stack/pop
; ========================================

(println "\n--- Section 9: stack/pop ---")

; 9.1 基本動作（LIFO確認）
(println "\n[9.1] stack/pop - 基本動作（LIFO）")
(def stack-pop-basic-pass
  (let [s (stack/new)
        s1 (stack/push s 1)
        s2 (stack/push s1 2)
        s3 (stack/push s2 3)
        result1 (stack/pop s3)
        result2 (stack/pop (get result1 :stack))
        result3 (stack/pop (get result2 :stack))]
    (and
      (= (get result1 :value) 3)
      (= (get result2 :value) 2)
      (= (get result3 :value) 1))))

(if stack-pop-basic-pass
  (println "✓ stack/popのLIFO動作は正しく動作した")
  (println "✗ stack/popのLIFO動作に問題がある"))

; 9.2 popとsize
(println "\n[9.2] stack/pop - サイズ変化")
(def stack-pop-size-pass
  (let [s (stack/new)
        s1 (stack/push s 1)
        s2 (stack/push s1 2)
        s3 (stack/push s2 3)
        result1 (stack/pop s3)
        new-s (get result1 :stack)]
    (= (stack/size new-s) 2)))

(if stack-pop-size-pass
  (println "✓ stack/popのサイズ変化は正しく動作した")
  (println "✗ stack/popのサイズ変化に問題がある"))

; 9.3 大量データのpop
(println "\n[9.3] stack/pop - 大量データ")
(def stack-pop-bulk-pass
  (let [s (reduce (fn [acc i] (stack/push acc i))
                  (stack/new)
                  (range 0 100))
        ; 最初の10個をpop
        final-s (reduce (fn [acc _]
                         (let [result (stack/pop acc)]
                           (get result :stack)))
                       s
                       (range 0 10))]
    (= (stack/size final-s) 90)))

(if stack-pop-bulk-pass
  (println "✓ stack/popの大量データ処理は正しく動作した")
  (println "✗ stack/popの大量データ処理に問題がある"))

; ========================================
; Section 10: stack/peek
; ========================================

(println "\n--- Section 10: stack/peek ---")

; 10.1 基本動作（非破壊）
(println "\n[10.1] stack/peek - 基本動作（非破壊）")
(def stack-peek-pass
  (let [s (stack/new)
        s1 (stack/push s 1)
        s2 (stack/push s1 2)
        val (stack/peek s2)]
    (and
      (= val 2)
      (= (stack/size s2) 2))))

(if stack-peek-pass
  (println "✓ stack/peekの非破壊動作は正しく動作した")
  (println "✗ stack/peekの非破壊動作に問題がある"))

; 10.2 複数回peek
(println "\n[10.2] stack/peek - 複数回peek")
(def stack-peek-multiple-pass
  (let [s (stack/push (stack/new) 42)
        val1 (stack/peek s)
        val2 (stack/peek s)
        val3 (stack/peek s)]
    (and
      (= val1 42)
      (= val2 42)
      (= val3 42))))

(if stack-peek-multiple-pass
  (println "✓ stack/peekの複数回実行は正しく動作した")
  (println "✗ stack/peekの複数回実行に問題がある"))

; ========================================
; Section 11: stack/empty?
; ========================================

(println "\n--- Section 11: stack/empty? ---")

; 11.1 基本動作
(println "\n[11.1] stack/empty? - 基本動作")
(def stack-empty-pass
  (let [s (stack/new)
        s1 (stack/push s 1)
        result1 (stack/pop s1)
        s2 (get result1 :stack)]
    (and
      (stack/empty? s)
      (not (stack/empty? s1))
      (stack/empty? s2))))

(if stack-empty-pass
  (println "✓ stack/empty?は正しく動作した")
  (println "✗ stack/empty?に問題がある"))

; ========================================
; Section 12: stack/size
; ========================================

(println "\n--- Section 12: stack/size ---")

; 12.1 基本動作
(println "\n[12.1] stack/size - 基本動作")
(def stack-size-pass
  (let [s (stack/new)
        s1 (stack/push s 1)
        s2 (stack/push s1 2)
        s3 (stack/push s2 3)]
    (and
      (= (stack/size s) 0)
      (= (stack/size s1) 1)
      (= (stack/size s2) 2)
      (= (stack/size s3) 3))))

(if stack-size-pass
  (println "✓ stack/sizeは正しく動作した")
  (println "✗ stack/sizeに問題がある"))

; ========================================
; Section 13: 統合テスト
; ========================================

(println "\n--- Section 13: 統合テスト ---")

; 13.1 QueueとStackの動作比較（FIFO vs LIFO）
(println "\n[13.1] QueueとStackの動作比較")
(def fifo-lifo-pass
  (let [data [1 2 3 4 5]
        q (reduce queue/enqueue (queue/new) data)
        s (reduce stack/push (stack/new) data)
        q-result1 (queue/dequeue q)
        q-result2 (queue/dequeue (get q-result1 :queue))
        s-result1 (stack/pop s)
        s-result2 (stack/pop (get s-result1 :stack))]
    (and
      (= (get q-result1 :value) 1)  ; FIFO: 最初に入れたものが最初に出る
      (= (get q-result2 :value) 2)
      (= (get s-result1 :value) 5)  ; LIFO: 最後に入れたものが最初に出る
      (= (get s-result2 :value) 4))))

(if fifo-lifo-pass
  (println "✓ FIFOとLIFOの動作比較は正しく動作した")
  (println "✗ FIFOとLIFOの動作比較に問題がある"))

; 13.2 大量データの完全処理（Queue）
(println "\n[13.2] 大量データの完全処理（Queue）")
(def queue-full-cycle-pass
  (let [data (range 0 1000)
        q (reduce queue/enqueue (queue/new) data)
        ; 最初の10個をdequeueして値を確認
        r1 (queue/dequeue q)
        r2 (queue/dequeue (get r1 :queue))
        r3 (queue/dequeue (get r2 :queue))]
    (and
      (= (get r1 :value) 0)
      (= (get r2 :value) 1)
      (= (get r3 :value) 2))))

(if queue-full-cycle-pass
  (println "✓ Queueの大量データ完全処理は正しく動作した")
  (println "✗ Queueの大量データ完全処理に問題がある"))

; 13.3 大量データの完全処理（Stack）
(println "\n[13.3] 大量データの完全処理（Stack）")
(def stack-full-cycle-pass
  (let [data (range 0 1000)
        s (reduce stack/push (stack/new) data)
        ; 最初の10個をpopして値を確認（LIFO）
        r1 (stack/pop s)
        r2 (stack/pop (get r1 :stack))
        r3 (stack/pop (get r2 :stack))]
    (and
      (= (get r1 :value) 999)  ; LIFO: 最後に入れたものが最初に出る
      (= (get r2 :value) 998)
      (= (get r3 :value) 997))))

(if stack-full-cycle-pass
  (println "✓ Stackの大量データ完全処理は正しく動作した")
  (println "✗ Stackの大量データ完全処理に問題がある"))

; 13.4 empty?とsizeの一貫性
(println "\n[13.4] empty?とsizeの一貫性")
(def consistency-pass
  (let [q (queue/new)
        s (stack/new)
        q1 (queue/enqueue q 1)
        s1 (stack/push s 1)]
    (and
      (= (queue/empty? q) (= (queue/size q) 0))
      (= (queue/empty? q1) (= (queue/size q1) 0))
      (= (stack/empty? s) (= (stack/size s) 0))
      (= (stack/empty? s1) (= (stack/size s1) 0)))))

(if consistency-pass
  (println "✓ empty?とsizeの一貫性は正しく動作した")
  (println "✗ empty?とsizeの一貫性に問題がある"))

; 13.5 ネストされたデータ構造
(println "\n[13.5] ネストされたデータ構造")
(def nested-pass
  (let [q (queue/new)
        q1 (queue/enqueue q [1 2 3])
        q2 (queue/enqueue q1 {:key "value"})
        q3 (queue/enqueue q2 (stack/push (stack/new) 42))
        result1 (queue/dequeue q3)
        val1 (get result1 :value)]
    (= val1 [1 2 3])))

(if nested-pass
  (println "✓ ネストされたデータ構造は正しく動作した")
  (println "✗ ネストされたデータ構造に問題がある"))

; ========================================
; 最終結果
; ========================================

(println "\n========================================")
(println "Queue/Stack関数 Torture Test 完了")
(println "========================================")
(println "\n全セクションが実行されました。")
(println "各セクションのチェックマーク (✓/✗) を確認してください。")
