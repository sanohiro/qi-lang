; map_torture_test.qi
; マップ操作関数（3個）の torture test
;
; map/select-keys, map/assoc-in, map/dissoc-in

(println "========================================")
(println "マップ操作関数 Torture Test 開始")
(println "========================================")

; ========================================
; Section 1: map/select-keys
; ========================================

(println "\n--- Section 1: map/select-keys ---")

; 1.1 基本動作
(println "\n[1.1] select-keys - 基本動作")
(def select-basic-pass
  (let [m {:a 1 :b 2 :c 3 :d 4}
        result (map/select-keys m [:a :c])]
    (and
      (map? result)
      (= (len (keys result)) 2))))

(if select-basic-pass
  (println "✓ select-keysの基本動作は正しく動作した")
  (println "✗ select-keysの基本動作に問題がある"))

; 1.2 存在しないキー
(println "\n[1.2] select-keys - 存在しないキー")
(def select-missing-pass
  (let [m {:a 1 :b 2}
        result (map/select-keys m [:a :z])]
    (and
      (map? result)
      (= (len (keys result)) 1))))

(if select-missing-pass
  (println "✓ select-keysの存在しないキーは正しく動作した")
  (println "✗ select-keysの存在しないキーに問題がある"))

; 1.3 空のキーリスト
(println "\n[1.3] select-keys - 空のキーリスト")
(def select-empty-pass
  (let [m {:a 1 :b 2 :c 3}
        result (map/select-keys m [])]
    (and
      (map? result)
      (= (len (keys result)) 0))))

(if select-empty-pass
  (println "✓ select-keysの空のキーリストは正しく動作した")
  (println "✗ select-keysの空のキーリストに問題がある"))

; 1.4 文字列キー
(println "\n[1.4] select-keys - 文字列キー")
(def select-string-pass
  (let [m {"name" "Alice" "age" 30 "city" "Tokyo"}
        result (map/select-keys m ["name" "city"])]
    (and
      (map? result)
      (= (len (keys result)) 2))))

(if select-string-pass
  (println "✓ select-keysの文字列キーは正しく動作した")
  (println "✗ select-keysの文字列キーに問題がある"))

; 1.5 大量データ
(println "\n[1.5] select-keys - 大量データ")
(def select-bulk-pass
  (let [m (list/zipmap (map (fn [x] (to-string x)) (range 0 1000)) (range 0 1000))
        keys-to-select (map (fn [x] (to-string x)) (range 0 100))
        result (map/select-keys m keys-to-select)]
    (and
      (map? result)
      (= (len (keys result)) 100))))

(if select-bulk-pass
  (println "✓ select-keysの大量データ処理は正しく動作した")
  (println "✗ select-keysの大量データ処理に問題がある"))

; ========================================
; Section 2: map/assoc-in
; ========================================

(println "\n--- Section 2: map/assoc-in ---")

; 2.1 基本動作
(println "\n[2.1] assoc-in - 基本動作")
(def assoc-basic-pass
  (let [m {:a {:b {:c 1}}}
        result (map/assoc-in m [:a :b :c] 99)]
    (map? result)))

(if assoc-basic-pass
  (println "✓ assoc-inの基本動作は正しく動作した")
  (println "✗ assoc-inの基本動作に問題がある"))

; 2.2 新しいパスの作成
(println "\n[2.2] assoc-in - 新しいパス")
(def assoc-new-path-pass
  (let [m {}
        result (map/assoc-in m [:a :b :c] 42)]
    (map? result)))

(if assoc-new-path-pass
  (println "✓ assoc-inの新しいパス作成は正しく動作した")
  (println "✗ assoc-inの新しいパス作成に問題がある"))

; 2.3 1階層のパス
(println "\n[2.3] assoc-in - 1階層")
(def assoc-single-pass
  (let [m {:a 1}
        result (map/assoc-in m [:a] 99)]
    (map? result)))

(if assoc-single-pass
  (println "✓ assoc-inの1階層は正しく動作した")
  (println "✗ assoc-inの1階層に問題がある"))

; 2.4 深いネスト
(println "\n[2.4] assoc-in - 深いネスト")
(def assoc-deep-pass
  (let [m {}
        result (map/assoc-in m [:a :b :c :d :e :f] "deep")]
    (map? result)))

(if assoc-deep-pass
  (println "✓ assoc-inの深いネストは正しく動作した")
  (println "✗ assoc-inの深いネストに問題がある"))

; 2.5 連続適用
(println "\n[2.5] assoc-in - 連続適用")
(def assoc-chain-pass
  (let [m {}
        r1 (map/assoc-in m [:user :name] "Alice")
        r2 (map/assoc-in r1 [:user :age] 30)
        r3 (map/assoc-in r2 [:user :city] "Tokyo")]
    (and
      (map? r3)
      (= (len (keys r3)) 1))))

(if assoc-chain-pass
  (println "✓ assoc-inの連続適用は正しく動作した")
  (println "✗ assoc-inの連続適用に問題がある"))

; 2.6 大量データ
(println "\n[2.6] assoc-in - 大量データ")
(def assoc-bulk-pass
  (let [m {}
        results (map (fn [x] (map/assoc-in m [:data (to-string x)] x)) (range 0 100))]
    (= (len results) 100)))

(if assoc-bulk-pass
  (println "✓ assoc-inの大量データ処理は正しく動作した")
  (println "✗ assoc-inの大量データ処理に問題がある"))

; ========================================
; Section 3: map/dissoc-in
; ========================================

(println "\n--- Section 3: map/dissoc-in ---")

; 3.1 基本動作
(println "\n[3.1] dissoc-in - 基本動作")
(def dissoc-basic-pass
  (let [m {:a {:b {:c 1 :d 2}}}
        result (map/dissoc-in m [:a :b :c])]
    (map? result)))

(if dissoc-basic-pass
  (println "✓ dissoc-inの基本動作は正しく動作した")
  (println "✗ dissoc-inの基本動作に問題がある"))

; 3.2 1階層のパス
(println "\n[3.2] dissoc-in - 1階層")
(def dissoc-single-pass
  (let [m {:a 1 :b 2 :c 3}
        result (map/dissoc-in m [:a])]
    (and
      (map? result)
      (= (len (keys result)) 2))))

(if dissoc-single-pass
  (println "✓ dissoc-inの1階層は正しく動作した")
  (println "✗ dissoc-inの1階層に問題がある"))

; 3.3 存在しないパス
(println "\n[3.3] dissoc-in - 存在しないパス")
(def dissoc-missing-pass
  (let [m {:a {:b 1}}
        result (map/dissoc-in m [:a :c])]
    (map? result)))

(if dissoc-missing-pass
  (println "✓ dissoc-inの存在しないパスは正しく動作した")
  (println "✗ dissoc-inの存在しないパスに問題がある"))

; 3.4 深いネスト
(println "\n[3.4] dissoc-in - 深いネスト")
(def dissoc-deep-pass
  (let [m {:a {:b {:c {:d {:e {:f 1}}}}}}
        result (map/dissoc-in m [:a :b :c :d :e :f])]
    (map? result)))

(if dissoc-deep-pass
  (println "✓ dissoc-inの深いネストは正しく動作した")
  (println "✗ dissoc-inの深いネストに問題がある"))

; 3.5 連続削除
(println "\n[3.5] dissoc-in - 連続削除")
(def dissoc-chain-pass
  (let [m {:user {:name "Alice" :age 30 :city "Tokyo"}}
        r1 (map/dissoc-in m [:user :city])
        r2 (map/dissoc-in r1 [:user :age])]
    (map? r2)))

(if dissoc-chain-pass
  (println "✓ dissoc-inの連続削除は正しく動作した")
  (println "✗ dissoc-inの連続削除に問題がある"))

; 3.6 大量データ
(println "\n[3.6] dissoc-in - 大量データ")
(def dissoc-bulk-pass
  (let [m {:data (list/zipmap (map (fn [x] (to-string x)) (range 0 100)) (range 0 100))}
        results (map (fn [x] (map/dissoc-in m [:data (to-string x)])) (range 0 50))]
    (= (len results) 50)))

(if dissoc-bulk-pass
  (println "✓ dissoc-inの大量データ処理は正しく動作した")
  (println "✗ dissoc-inの大量データ処理に問題がある"))

; ========================================
; Section 4: 統合テスト
; ========================================

(println "\n--- Section 4: 統合テスト ---")

; 4.1 select-keys + assoc-in
(println "\n[4.1] select-keys + assoc-in")
(def integration1-pass
  (let [m {:a 1 :b 2 :c 3}
        selected (map/select-keys m [:a :b])
        updated (map/assoc-in selected [:nested :value] 99)]
    (and
      (map? selected)
      (map? updated))))

(if integration1-pass
  (println "✓ select-keys + assoc-in統合は正しく動作した")
  (println "✗ select-keys + assoc-in統合に問題がある"))

; 4.2 assoc-in + dissoc-in
(println "\n[4.2] assoc-in + dissoc-in")
(def integration2-pass
  (let [m {}
        added (map/assoc-in m [:user :name] "Alice")
        removed (map/dissoc-in added [:user :name])]
    (and
      (map? added)
      (map? removed))))

(if integration2-pass
  (println "✓ assoc-in + dissoc-in統合は正しく動作した")
  (println "✗ assoc-in + dissoc-in統合に問題がある"))

; 4.3 3関数の組み合わせ
(println "\n[4.3] 3関数の組み合わせ")
(def integration3-pass
  (let [m {:user {:name "Alice" :age 30 :city "Tokyo" :email "alice@example.com"}}
        selected (map/select-keys m [:user])
        updated (map/assoc-in selected [:user :status] "active")
        cleaned (map/dissoc-in updated [:user :email])]
    (map? cleaned)))

(if integration3-pass
  (println "✓ 3関数の組み合わせは正しく動作した")
  (println "✗ 3関数の組み合わせに問題がある"))

; ========================================
; Section 5: 高負荷テスト
; ========================================

(println "\n--- Section 5: 高負荷テスト ---")

; 5.1 大量のselect-keys
(println "\n[5.1] 大量のselect-keys")
(def bulk1-pass
  (let [m (list/zipmap (map (fn [x] (to-string x)) (range 0 1000)) (range 0 1000))
        results (map (fn [_] (map/select-keys m ["0" "100" "500"])) (range 0 100))]
    (= (len results) 100)))

(if bulk1-pass
  (println "✓ 大量のselect-keysは正しく動作した")
  (println "✗ 大量のselect-keysに問題がある"))

; 5.2 大量のassoc-in
(println "\n[5.2] 大量のassoc-in")
(def bulk2-pass
  (let [m {}
        results (map (fn [x] (map/assoc-in m [:level1 :level2 (to-string x)] x)) (range 0 1000))]
    (= (len results) 1000)))

(if bulk2-pass
  (println "✓ 大量のassoc-inは正しく動作した")
  (println "✗ 大量のassoc-inに問題がある"))

; 5.3 並列処理
(println "\n[5.3] 並列処理")
(def parallel-pass
  (let [m {:data (list/zipmap (map (fn [x] (to-string x)) (range 0 100)) (range 0 100))}
        results (pmap (fn [x] (map/dissoc-in m [:data (to-string x)])) (range 0 100))]
    (= (len results) 100)))

(if parallel-pass
  (println "✓ 並列処理は正しく動作した")
  (println "✗ 並列処理に問題がある"))

; ========================================
; 最終結果
; ========================================

(println "\n========================================")
(println "マップ操作関数 Torture Test 完了")
(println "========================================")
(println "\n全セクションが実行されました。")
(println "各セクションのチェックマーク (✓/✗) を確認してください。")
