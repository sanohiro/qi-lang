; list_torture_test.qi
; リスト操作関数（8個）の torture test
;
; list/split-at, list/interleave, list/frequencies, list/chunk,
; list/zipmap, list/take-nth, list/dedupe, list/drop-last

(println "========================================")
(println "リスト操作関数 Torture Test 開始")
(println "========================================")

; ========================================
; Section 1: list/split-at
; ========================================

(println "\n--- Section 1: list/split-at ---")

; 1.1 基本動作
(println "\n[1.1] split-at - 基本動作")
(def split-basic-pass
  (let [r1 (list/split-at 2 [1 2 3 4 5])
        r2 (list/split-at 0 [1 2 3])
        r3 (list/split-at 3 [1 2 3])]
    (and
      (= (len r1) 2)
      (= (len (first r1)) 2)
      (= (len (last r1)) 3)
      (= (len r2) 2)
      (= (len (first r2)) 0)
      (= (len r3) 2)
      (= (len (last r3)) 0))))

(if split-basic-pass
  (println "✓ split-atの基本動作は正しく動作した")
  (println "✗ split-atの基本動作に問題がある"))

; 1.2 境界値
(println "\n[1.2] split-at - 境界値")
(def split-boundary-pass
  (and
    (= (list/split-at 0 []) [[] []])
    (= (list/split-at 10 [1 2 3]) [[1 2 3] []])
    (= (list/split-at 5 [1 2 3 4 5 6 7 8 9 10]) [[1 2 3 4 5] [6 7 8 9 10]])))

(if split-boundary-pass
  (println "✓ split-atの境界値は正しく動作した")
  (println "✗ split-atの境界値に問題がある"))

; 1.3 大量データ
(println "\n[1.3] split-at - 大量データ")
(def split-bulk-pass
  (let [data (range 0 10000)
        result (list/split-at 5000 data)]
    (and
      (= (len result) 2)
      (= (len (first result)) 5000)
      (= (len (last result)) 5000))))

(if split-bulk-pass
  (println "✓ split-atの大量データ処理は正しく動作した")
  (println "✗ split-atの大量データ処理に問題がある"))

; ========================================
; Section 2: list/interleave
; ========================================

(println "\n--- Section 2: list/interleave ---")

; 2.1 基本動作
(println "\n[2.1] interleave - 基本動作")
(def interleave-basic-pass
  (let [r1 (list/interleave [1 2 3] [4 5 6])
        r2 (list/interleave [1] [2])]
    (and
      (= (len r1) 6)
      (= (first r1) 1)
      (= (nth r1 1) 4)
      (= (len r2) 2))))

(if interleave-basic-pass
  (println "✓ interleaveの基本動作は正しく動作した")
  (println "✗ interleaveの基本動作に問題がある"))

; 2.2 異なる長さのリスト
(println "\n[2.2] interleave - 異なる長さ")
(def interleave-diff-pass
  (let [r1 (list/interleave [1 2 3] [4 5])
        r2 (list/interleave [1] [2 3 4])
        r3 (list/interleave [] [1 2 3])]
    (and
      (= (len r1) 4)
      (= (len r2) 2)
      (= (len r3) 0))))

(if interleave-diff-pass
  (println "✓ interleaveの異なる長さは正しく動作した")
  (println "✗ interleaveの異なる長さに問題がある"))

; 2.3 大量データ
(println "\n[2.3] interleave - 大量データ")
(def interleave-bulk-pass
  (let [list1 (range 0 5000)
        list2 (range 5000 10000)
        result (list/interleave list1 list2)]
    (and
      (= (len result) 10000)
      (= (first result) 0)
      (= (nth result 1) 5000))))

(if interleave-bulk-pass
  (println "✓ interleaveの大量データ処理は正しく動作した")
  (println "✗ interleaveの大量データ処理に問題がある"))

; ========================================
; Section 3: list/frequencies
; ========================================

(println "\n--- Section 3: list/frequencies ---")

; 3.1 基本動作
(println "\n[3.1] frequencies - 基本動作")
(def freq-basic-pass
  (let [result (list/frequencies [1 2 2 3 3 3])]
    (and
      (map? result)
      (= (len (keys result)) 3))))

(if freq-basic-pass
  (println "✓ frequenciesの基本動作は正しく動作した")
  (println "✗ frequenciesの基本動作に問題がある"))

; 3.2 文字列での使用
(println "\n[3.2] frequencies - 文字列")
(def freq-string-pass
  (let [result (list/frequencies ["a" "b" "a" "c" "b" "a"])]
    (and
      (map? result)
      (= (len (keys result)) 3))))

(if freq-string-pass
  (println "✓ frequenciesの文字列は正しく動作した")
  (println "✗ frequenciesの文字列に問題がある"))

; 3.3 空リスト
(println "\n[3.3] frequencies - 空リスト")
(def freq-empty-pass
  (let [result (list/frequencies [])]
    (and
      (map? result)
      (= (len (keys result)) 0))))

(if freq-empty-pass
  (println "✓ frequenciesの空リストは正しく動作した")
  (println "✗ frequenciesの空リストに問題がある"))

; 3.4 大量データ
(println "\n[3.4] frequencies - 大量データ")
(def freq-bulk-pass
  (let [data (map (fn [x] (% x 10)) (range 0 10000))
        result (list/frequencies data)]
    (and
      (map? result)
      (= (len (keys result)) 10))))

(if freq-bulk-pass
  (println "✓ frequenciesの大量データ処理は正しく動作した")
  (println "✗ frequenciesの大量データ処理に問題がある"))

; ========================================
; Section 4: list/chunk
; ========================================

(println "\n--- Section 4: list/chunk ---")

; 4.1 基本動作
(println "\n[4.1] chunk - 基本動作")
(def chunk-basic-pass
  (let [r1 (list/chunk 2 [1 2 3 4 5 6])
        r2 (list/chunk 3 [1 2 3 4 5 6 7 8 9])
        r3 (list/chunk 1 [1 2 3])]
    (and
      (= (len r1) 3)
      (= (len (first r1)) 2)
      (= (len r2) 3)
      (= (len r3) 3))))

(if chunk-basic-pass
  (println "✓ chunkの基本動作は正しく動作した")
  (println "✗ chunkの基本動作に問題がある"))

; 4.2 不完全なチャンク
(println "\n[4.2] chunk - 不完全なチャンク")
(def chunk-partial-pass
  (let [r1 (list/chunk 2 [1 2 3 4 5])
        r2 (list/chunk 3 [1 2])
        r3 (list/chunk 5 [1 2 3])]
    (and
      (= (len r1) 3)
      (= (len (last r1)) 1)
      (= (len r2) 1)
      (= (len r3) 1))))

(if chunk-partial-pass
  (println "✓ chunkの不完全なチャンクは正しく動作した")
  (println "✗ chunkの不完全なチャンクに問題がある"))

; 4.3 大量データ
(println "\n[4.3] chunk - 大量データ")
(def chunk-bulk-pass
  (let [data (range 0 10000)
        result (list/chunk 100 data)]
    (and
      (= (len result) 100)
      (= (len (first result)) 100)
      (= (len (last result)) 100))))

(if chunk-bulk-pass
  (println "✓ chunkの大量データ処理は正しく動作した")
  (println "✗ chunkの大量データ処理に問題がある"))

; ========================================
; Section 5: list/zipmap
; ========================================

(println "\n--- Section 5: list/zipmap ---")

; 5.1 基本動作
(println "\n[5.1] zipmap - 基本動作")
(def zipmap-basic-pass
  (let [result (list/zipmap [:a :b :c] [1 2 3])]
    (and
      (map? result)
      (= (len (keys result)) 3))))

(if zipmap-basic-pass
  (println "✓ zipmapの基本動作は正しく動作した")
  (println "✗ zipmapの基本動作に問題がある"))

; 5.2 異なる長さ
(println "\n[5.2] zipmap - 異なる長さ")
(def zipmap-diff-pass
  (let [result1 (list/zipmap [:a :b :c] [1 2])
        result2 (list/zipmap [:a :b] [1 2 3 4])]
    (and
      (map? result1)
      (map? result2))))

(if zipmap-diff-pass
  (println "✓ zipmapの異なる長さは正しく動作した")
  (println "✗ zipmapの異なる長さに問題がある"))

; 5.3 文字列キー
(println "\n[5.3] zipmap - 文字列キー")
(def zipmap-string-pass
  (let [result (list/zipmap ["name" "age" "city"] ["Alice" 30 "Tokyo"])]
    (and
      (map? result)
      (= (len (keys result)) 3))))

(if zipmap-string-pass
  (println "✓ zipmapの文字列キーは正しく動作した")
  (println "✗ zipmapの文字列キーに問題がある"))

; 5.4 大量データ
(println "\n[5.4] zipmap - 大量データ")
(def zipmap-bulk-pass
  (let [keys-data (range 0 1000)
        vals-data (range 1000 2000)
        result (list/zipmap keys-data vals-data)]
    (and
      (map? result)
      (= (len (keys result)) 1000))))

(if zipmap-bulk-pass
  (println "✓ zipmapの大量データ処理は正しく動作した")
  (println "✗ zipmapの大量データ処理に問題がある"))

; ========================================
; Section 6: list/take-nth
; ========================================

(println "\n--- Section 6: list/take-nth ---")

; 6.1 基本動作
(println "\n[6.1] take-nth - 基本動作")
(def take-nth-basic-pass
  (let [r1 (list/take-nth 2 [1 2 3 4 5 6])
        r2 (list/take-nth 3 [1 2 3 4 5 6 7 8 9])
        r3 (list/take-nth 1 [1 2 3])]
    (and
      (= (len r1) 3)
      (= (first r1) 1)
      (= (len r2) 3)
      (= (len r3) 3))))

(if take-nth-basic-pass
  (println "✓ take-nthの基本動作は正しく動作した")
  (println "✗ take-nthの基本動作に問題がある"))

; 6.2 境界値
(println "\n[6.2] take-nth - 境界値")
(def take-nth-boundary-pass
  (let [r1 (list/take-nth 10 [1 2 3])
        r2 (list/take-nth 5 [1 2 3 4 5 6 7 8 9 10])
        r3 (list/take-nth 100 (range 0 50))]
    (and
      (= (len r1) 1)
      (= (len r2) 2)
      (= (len r3) 1))))

(if take-nth-boundary-pass
  (println "✓ take-nthの境界値は正しく動作した")
  (println "✗ take-nthの境界値に問題がある"))

; 6.3 大量データ
(println "\n[6.3] take-nth - 大量データ")
(def take-nth-bulk-pass
  (let [data (range 0 10000)
        result (list/take-nth 10 data)]
    (and
      (= (len result) 1000)
      (= (first result) 0)
      (= (last result) 9990))))

(if take-nth-bulk-pass
  (println "✓ take-nthの大量データ処理は正しく動作した")
  (println "✗ take-nthの大量データ処理に問題がある"))

; ========================================
; Section 7: list/dedupe
; ========================================

(println "\n--- Section 7: list/dedupe ---")

; 7.1 基本動作
(println "\n[7.1] dedupe - 基本動作")
(def dedupe-basic-pass
  (let [r1 (list/dedupe [1 1 2 2 3 3])
        r2 (list/dedupe [1 2 3 4 5])
        r3 (list/dedupe [1 1 1 1])]
    (and
      (= (len r1) 3)
      (= (len r2) 5)
      (= (len r3) 1))))

(if dedupe-basic-pass
  (println "✓ dedupeの基本動作は正しく動作した")
  (println "✗ dedupeの基本動作に問題がある"))

; 7.2 非連続重複
(println "\n[7.2] dedupe - 非連続重複")
(def dedupe-nonseq-pass
  (let [r1 (list/dedupe [1 2 1 2 1])
        r2 (list/dedupe [1 1 2 2 1 1])
        r3 (list/dedupe ["a" "a" "b" "a"])]
    (and
      (= (len r1) 5)
      (= (len r2) 3)
      (= (len r3) 3))))

(if dedupe-nonseq-pass
  (println "✓ dedupeの非連続重複は正しく動作した")
  (println "✗ dedupeの非連続重複に問題がある"))

; 7.3 空リスト
(println "\n[7.3] dedupe - 空リスト")
(def dedupe-empty-pass
  (let [r (list/dedupe [])]
    (= (len r) 0)))

(if dedupe-empty-pass
  (println "✓ dedupeの空リストは正しく動作した")
  (println "✗ dedupeの空リストに問題がある"))

; 7.4 大量データ
(println "\n[7.4] dedupe - 大量データ")
(def dedupe-bulk-pass
  (let [data (map (fn [x] (/ x 2)) (range 0 10000))
        result (list/dedupe data)]
    (and
      (= (len result) 5000)
      (= (first result) 0)
      (= (last result) 4999))))

(if dedupe-bulk-pass
  (println "✓ dedupeの大量データ処理は正しく動作した")
  (println "✗ dedupeの大量データ処理に問題がある"))

; ========================================
; Section 8: list/drop-last
; ========================================

(println "\n--- Section 8: list/drop-last ---")

; 8.1 基本動作
(println "\n[8.1] drop-last - 基本動作")
(def drop-last-basic-pass
  (let [r1 (list/drop-last 2 [1 2 3 4 5])
        r2 (list/drop-last 1 [1 2 3])
        r3 (list/drop-last 0 [1 2 3])]
    (and
      (= (len r1) 3)
      (= (len r2) 2)
      (= (len r3) 3))))

(if drop-last-basic-pass
  (println "✓ drop-lastの基本動作は正しく動作した")
  (println "✗ drop-lastの基本動作に問題がある"))

; 8.2 境界値
(println "\n[8.2] drop-last - 境界値")
(def drop-last-boundary-pass
  (let [r1 (list/drop-last 5 [1 2 3])
        r2 (list/drop-last 10 [1 2 3])
        r3 (list/drop-last 0 [])]
    (and
      (= (len r1) 0)
      (= (len r2) 0)
      (= (len r3) 0))))

(if drop-last-boundary-pass
  (println "✓ drop-lastの境界値は正しく動作した")
  (println "✗ drop-lastの境界値に問題がある"))

; 8.3 大量データ
(println "\n[8.3] drop-last - 大量データ")
(def drop-last-bulk-pass
  (let [data (range 0 10000)
        result (list/drop-last 5000 data)]
    (and
      (= (len result) 5000)
      (= (first result) 0)
      (= (last result) 4999))))

(if drop-last-bulk-pass
  (println "✓ drop-lastの大量データ処理は正しく動作した")
  (println "✗ drop-lastの大量データ処理に問題がある"))

; ========================================
; Section 9: 統合テスト
; ========================================

(println "\n--- Section 9: 統合テスト ---")

; 9.1 複数関数の組み合わせ
(println "\n[9.1] 複数関数の組み合わせ")
(def integration-pass
  (let [data [1 1 2 2 3 3 4 4 5 5]
        deduped (list/dedupe data)
        chunks (list/chunk 2 deduped)
        taken (list/take-nth 1 deduped)]
    (and
      (= (len deduped) 5)
      (= (len chunks) 3)
      (= (len taken) 5))))

(if integration-pass
  (println "✓ 複数関数の組み合わせは正しく動作した")
  (println "✗ 複数関数の組み合わせに問題がある"))

; 9.2 パイプラインでの使用
(println "\n[9.2] パイプラインでの使用")
(def pipeline-pass
  (let [result ([1 2 3 4 5 6 7 8 9 10] |> (list/take-nth 2) |> (list/drop-last 2))]
    (= (len result) 3)))

(if pipeline-pass
  (println "✓ パイプライン使用は正しく動作した")
  (println "✗ パイプライン使用に問題がある"))

; ========================================
; Section 10: 高負荷テスト
; ========================================

(println "\n--- Section 10: 高負荷テスト ---")

; 10.1 大量データでの統合
(println "\n[10.1] 大量データでの統合")
(def bulk-integration-pass
  (let [data (range 0 10000)
        split (list/split-at 5000 data)
        chunked (list/chunk 100 data)
        nth-taken (list/take-nth 10 data)]
    (and
      (= (len split) 2)
      (= (len chunked) 100)
      (= (len nth-taken) 1000))))

(if bulk-integration-pass
  (println "✓ 大量データでの統合は正しく動作した")
  (println "✗ 大量データでの統合に問題がある"))

; 10.2 並列処理
(println "\n[10.2] 並列処理")
(def parallel-pass
  (let [data (range 0 1000)
        result (pmap (fn [x] (list/take-nth 2 (range 0 x))) data)]
    (and
      (= (len result) 1000)
      (list? (first result)))))

(if parallel-pass
  (println "✓ 並列処理は正しく動作した")
  (println "✗ 並列処理に問題がある"))

; ========================================
; 最終結果
; ========================================

(println "\n========================================")
(println "リスト操作関数 Torture Test 完了")
(println "========================================")
(println "\n全セクションが実行されました。")
(println "各セクションのチェックマーク (✓/✗) を確認してください。")
