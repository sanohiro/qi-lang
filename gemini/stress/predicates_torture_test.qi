; predicates_torture_test.qi
; Core述語関数（20個）の torture test
;
; 型チェック(11): nil?, list?, vector?, map?, string?, integer?, float?, number?, keyword?, function?, atom?
; コレクション(3): coll?, sequential?, empty?
; 状態(3): some?, true?, false?
; 数値(5): even?, odd?, positive?, negative?, zero?

(println "========================================")
(println "述語関数 Torture Test 開始")
(println "========================================")

; ========================================
; Section 1: 型チェック述語 - 基本テスト
; ========================================

(println "\n--- Section 1: 型チェック述語 - 基本テスト ---")

; 1.1 nil? - 全型でテスト
(println "\n[1.1] nil?")
(def nil-test-pass
  (and
    (nil? nil)
    (not (nil? true))
    (not (nil? false))
    (not (nil? 0))
    (not (nil? ""))
    (not (nil? '()))
    (not (nil? []))
    (not (nil? {}))
    (not (nil? :keyword))
    (not (nil? (fn [] 1)))
    (not (nil? (atom 0)))))

(if nil-test-pass
  (println "✓ nil?は正しく動作した")
  (println "✗ nil?に問題がある"))

; 1.2 list? - リスト判定
(println "\n[1.2] list?")
(def list-test-pass
  (and
    (list? '())
    (list? '(1))
    (list? '(1 2 3))
    (list? '((1 2) (3 4)))
    (not (list? []))
    (not (list? [1 2 3]))
    (not (list? {}))
    (not (list? 42))
    (not (list? "list"))
    (not (list? nil))))

(if list-test-pass
  (println "✓ list?は正しく動作した")
  (println "✗ list?に問題がある"))

; 1.3 vector? - ベクタ判定
(println "\n[1.3] vector?")
(def vector-test-pass
  (and
    (vector? [])
    (vector? [1])
    (vector? [1 2 3])
    (vector? [[1 2] [3 4]])
    (not (vector? '()))
    (not (vector? '(1 2 3)))
    (not (vector? {}))
    (not (vector? 42))
    (not (vector? "vector"))
    (not (vector? nil))))

(if vector-test-pass
  (println "✓ vector?は正しく動作した")
  (println "✗ vector?に問題がある"))

; 1.4 map? - マップ判定
(println "\n[1.4] map?")
(def map-test-pass
  (and
    (map? {})
    (map? {:a 1})
    (map? {:a 1 :b 2})
    (map? {:nested {:a 1}})
    (not (map? []))
    (not (map? '()))
    (not (map? 42))
    (not (map? "map"))
    (not (map? nil))))

(if map-test-pass
  (println "✓ map?は正しく動作した")
  (println "✗ map?に問題がある"))

; 1.5 string? - 文字列判定
(println "\n[1.5] string?")
(def string-test-pass
  (and
    (string? "")
    (string? "hello")
    (string? "日本語")
    (string? f"interpolated {1+1}")
    (not (string? 42))
    (not (string? :keyword))
    (not (string? '()))
    (not (string? []))
    (not (string? {}))
    (not (string? nil))))

(if string-test-pass
  (println "✓ string?は正しく動作した")
  (println "✗ string?に問題がある"))

; 1.6 integer? と float? と number?
(println "\n[1.6] integer?, float?, number?")
(def number-test-pass
  (and
    (integer? 0)
    (integer? 42)
    (integer? -10)
    (not (integer? 3.14))
    (not (integer? "42"))
    (float? 0.0)
    (float? 3.14)
    (float? -2.71)
    (not (float? 42))
    (not (float? "3.14"))
    (number? 0)
    (number? 42)
    (number? 3.14)
    (not (number? "42"))))

(if number-test-pass
  (println "✓ integer?, float?, number?は正しく動作した")
  (println "✗ 数値型判定に問題がある"))

; 1.7 keyword? - キーワード判定
(println "\n[1.7] keyword?")
(def keyword-test-pass
  (and
    (keyword? :a)
    (keyword? :test)
    (keyword? :日本語)
    (keyword? :123)
    (not (keyword? "keyword"))
    (not (keyword? 'symbol))
    (not (keyword? 42))
    (not (keyword? nil))))

(if keyword-test-pass
  (println "✓ keyword?は正しく動作した")
  (println "✗ keyword?に問題がある"))

; 1.8 function? - 関数判定
(println "\n[1.8] function?")
(def fn1 (fn [x] x))
(def function-test-pass
  (and
    (function? fn1)
    (function? (fn [] 1))
    (function? (fn [x y] (+ x y)))
    (not (function? 42))
    (not (function? "function"))
    (not (function? nil))))

(if function-test-pass
  (println "✓ function?は正しく動作した")
  (println "✗ function?に問題がある"))

; 1.9 atom? - atom判定
(println "\n[1.9] atom?")
(def a1 (atom 0))
(def a2 (atom '(1 2 3)))
(def atom-test-pass
  (and
    (atom? a1)
    (atom? a2)
    (atom? (atom nil))
    (not (atom? 0))
    (not (atom? "atom"))
    (not (atom? []))
    (not (atom? nil))))

(if atom-test-pass
  (println "✓ atom?は正しく動作した")
  (println "✗ atom?に問題がある"))

; ========================================
; Section 2: コレクション述語
; ========================================

(println "\n--- Section 2: コレクション述語 ---")

; 2.1 coll? - コレクション判定
(println "\n[2.1] coll?")
(def coll-test-pass
  (and
    (coll? '())
    (coll? '(1 2 3))
    (coll? [])
    (coll? [1 2 3])
    (coll? {})
    (coll? {:a 1})
    (not (coll? 42))
    (not (coll? "string"))
    (not (coll? :keyword))
    (not (coll? nil))
    (not (coll? (fn [] 1)))))

(if coll-test-pass
  (println "✓ coll?は正しく動作した")
  (println "✗ coll?に問題がある"))

; 2.2 sequential? - シーケンシャル判定
(println "\n[2.2] sequential?")
(def seq-test-pass
  (and
    (sequential? '())
    (sequential? '(1 2 3))
    (sequential? [])
    (sequential? [1 2 3])
    (not (sequential? {}))
    (not (sequential? {:a 1}))
    (not (sequential? 42))
    (not (sequential? "string"))
    (not (sequential? nil))))

(if seq-test-pass
  (println "✓ sequential?は正しく動作した")
  (println "✗ sequential?に問題がある"))

; 2.3 empty? - 空判定
(println "\n[2.3] empty?")
(def empty-test-pass
  (and
    (empty? nil)
    (empty? '())
    (empty? [])
    (empty? {})
    (empty? "")
    (not (empty? '(1)))
    (not (empty? [1]))
    (not (empty? {:a 1}))
    (not (empty? "a"))))

(if empty-test-pass
  (println "✓ empty?は正しく動作した")
  (println "✗ empty?に問題がある"))

; ========================================
; Section 3: 状態述語
; ========================================

(println "\n--- Section 3: 状態述語 ---")

; 3.1 some? - nilでない判定
(println "\n[3.1] some?")
(def some-test-pass
  (and
    (some? true)
    (some? false)
    (some? 0)
    (some? "")
    (some? '())
    (some? [])
    (some? {})
    (some? :keyword)
    (not (some? nil))))

(if some-test-pass
  (println "✓ some?は正しく動作した")
  (println "✗ some?に問題がある"))

; 3.2 true? - 厳密なtrue判定
(println "\n[3.2] true?")
(def true-test-pass
  (and
    (true? true)
    (not (true? false))
    (not (true? 1))
    (not (true? "true"))
    (not (true? '(1)))
    (not (true? nil))))

(if true-test-pass
  (println "✓ true?は正しく動作した")
  (println "✗ true?に問題がある"))

; 3.3 false? - 厳密なfalse判定
(println "\n[3.3] false?")
(def false-test-pass
  (and
    (false? false)
    (not (false? true))
    (not (false? 0))
    (not (false? ""))
    (not (false? nil))
    (not (false? '()))))

(if false-test-pass
  (println "✓ false?は正しく動作した")
  (println "✗ false?に問題がある"))

; ========================================
; Section 4: 数値述語
; ========================================

(println "\n--- Section 4: 数値述語 ---")

; 4.1 even? と odd?
(println "\n[4.1] even? と odd?")
(def even-odd-test-pass
  (and
    (even? 0)
    (even? 2)
    (even? -4)
    (even? 1000)
    (not (even? 1))
    (not (even? -3))
    (odd? 1)
    (odd? 3)
    (odd? -5)
    (odd? 999)
    (not (odd? 0))
    (not (odd? 2))
    (not (odd? -4))))

(if even-odd-test-pass
  (println "✓ even?とodd?は正しく動作した")
  (println "✗ even?とodd?に問題がある"))

; 4.2 positive?, negative?, zero?
(println "\n[4.2] positive?, negative?, zero?")
(def sign-test-pass
  (and
    (positive? 1)
    (positive? 42)
    (positive? 0.1)
    (positive? 3.14)
    (not (positive? 0))
    (not (positive? -1))
    (not (positive? -0.1))
    (negative? -1)
    (negative? -42)
    (negative? -0.1)
    (negative? -3.14)
    (not (negative? 0))
    (not (negative? 1))
    (not (negative? 0.1))
    (zero? 0)
    (zero? 0.0)
    (not (zero? 1))
    (not (zero? 0.1))
    (not (zero? -1))))

(if sign-test-pass
  (println "✓ positive?, negative?, zero?は正しく動作した")
  (println "✗ 符号判定に問題がある"))

; ========================================
; Section 5: パイプラインとの組み合わせ
; ========================================

(println "\n--- Section 5: パイプラインとの組み合わせ ---")

; 5.1 述語とfilter
(println "\n[5.1] 述語とfilter")
(def mixed-data [nil 1 2 3 "string" :keyword '(1 2) [3 4] {:a 1} true false 0 -1 3.14])

(def numbers-only (filter number? mixed-data))
(def colls-only (filter coll? mixed-data))
(def seqs-only (filter sequential? mixed-data))

(def filter-test-pass
  (and
    (= (len numbers-only) 6)
    (= (len colls-only) 3)
    (= (len seqs-only) 2)))

(if filter-test-pass
  (println "✓ filterと述語の組み合わせが正しく動作した")
  (println "✗ filterと述語の組み合わせに問題がある"))

; 5.2 パイプラインで述語を使う
(println "\n[5.2] パイプラインで述語を使う")
(def pipeline-result
  ([1 2 3 4 5 6 7 8 9 10]
   |> (filter even?)
   |> len))

(if (= pipeline-result 5)
  (println "✓ パイプライン内で述語が正しく動作した")
  (println "✗ パイプライン内で述語に問題がある"))

; ========================================
; Section 6: 大量データテスト
; ========================================

(println "\n--- Section 6: 大量データテスト ---")

; 6.1 大量データでのfilter（10000要素）
(println "\n[6.1] 大量データでのfilter (10000要素)")
(def large-data (range 0 10000))
(def large-evens (filter even? large-data))
(def large-positives (filter positive? large-data))

(def large-test-pass
  (and
    (= (len large-evens) 5000)
    (= (len large-positives) 9999)))

(if large-test-pass
  (println "✓ 大量データでのフィルタリングが成功した")
  (println "✗ 大量データでのフィルタリングに失敗"))

; 6.2 述語を使った複雑な条件
(println "\n[6.2] 述語を使った複雑な条件")
(def test-data (range -100 101))

; 正の偶数をカウント
(def positive-evens
  (filter (fn [x] (and (positive? x) (even? x))) test-data))

; 負の奇数をカウント
(def negative-odds
  (filter (fn [x] (and (negative? x) (odd? x))) test-data))

(def complex-condition-pass
  (and
    (= (len positive-evens) 50)
    (= (len negative-odds) 50)))

(if complex-condition-pass
  (println "✓ 複雑な条件判定が成功した")
  (println "✗ 複雑な条件判定に失敗"))

; 6.3 並列処理での述語使用
(println "\n[6.3] 並列処理での述語使用")
(def parallel-data (range 0 1000))

; 並列処理で述語を使ってフィルタリング
(def parallel-evens (pmap (fn [x] (if (even? x) x nil)) parallel-data))
(def parallel-evens-filtered (filter (fn [x] (not (nil? x))) parallel-evens))

(if (= (len parallel-evens-filtered) 500)
  (println "✓ 並列処理での述語が正しく動作した")
  (println "✗ 並列処理での述語に問題がある"))

; ========================================
; 最終結果
; ========================================

(println "\n========================================")
(println "述語関数 Torture Test 完了")
(println "========================================")
(println "\n全セクションが実行されました。")
(println "各セクションのチェックマーク (✓/✗) を確認してください。")
