; ========================================
; matchパターンストレステスト
; ========================================
;
; 目的: matchのパターンマッチングの全パターンをテスト
;
; テスト項目:
; 1. 基本的なパターンマッチング（全型）
; 2. orパターン（|）の複雑な組み合わせ
; 3. whenガード条件の複雑なケース
; 4. :asバインディングとwhenの組み合わせ
; 5. ネストしたデータ構造のマッチング
; 6. ...rest / & rest パターン
; 7. 実世界で使いそうなパターン
;
; なぜこれが重要か:
; - matchはQiの強力な機能の一つ
; - パターンの組み合わせは無限にある
; - 実装の複雑さからバグが出やすい

(println "=== Match Patterns Stress Test ===\n")

; ========================================
; Test 1: 全てのリテラル型のマッチング
; ========================================
; 理由: すべての基本型が正しくマッチすることを確認

(println "Test 1: All Literal Types Matching")

(defn match-type [value]
  (match value
    nil -> "nil"
    true -> "true"
    false -> "false"
    0 -> "zero"
    42 -> "forty-two"
    3.14 -> "pi"
    "hello" -> "string"
    :keyword -> "keyword"
    _ -> "other"))

(if (and
      (= "nil" (match-type nil))
      (= "true" (match-type true))
      (= "false" (match-type false))
      (= "zero" (match-type 0))
      (= "forty-two" (match-type 42))
      (= "pi" (match-type 3.14))
      (= "string" (match-type "hello"))
      (= "keyword" (match-type :keyword))
      (= "other" (match-type [1 2 3])))
  (println "  ✓ 全リテラル型マッチング成功")
  (println "  ✗ 全リテラル型マッチング失敗"))

; ========================================
; Test 2: 複雑なorパターン
; ========================================
; 理由: 複数の条件を1つのアームで処理できることを確認

(println "\nTest 2: Complex OR Patterns")

(defn classify-number [n]
  (match n
    0 -> "zero"
    1 | 2 | 3 | 4 | 5 -> "small"
    10 | 20 | 30 -> "round"
    100 | 200 | 300 -> "big-round"
    _ -> "other"))

(if (and
      (= "zero" (classify-number 0))
      (= "small" (classify-number 3))
      (= "round" (classify-number 20))
      (= "big-round" (classify-number 200))
      (= "other" (classify-number 99)))
  (println "  ✓ 数値orパターン成功")
  (println "  ✗ 数値orパターン失敗"))

; 文字列のorパターン
(defn classify-command [cmd]
  (match cmd
    "quit" | "exit" | "q" -> "exit-command"
    "help" | "h" | "?" -> "help-command"
    "save" | "write" | "w" -> "save-command"
    _ -> "unknown"))

(if (and
      (= "exit-command" (classify-command "quit"))
      (= "exit-command" (classify-command "exit"))
      (= "help-command" (classify-command "?"))
      (= "save-command" (classify-command "write"))
      (= "unknown" (classify-command "foo")))
  (println "  ✓ 文字列orパターン成功")
  (println "  ✗ 文字列orパターン失敗"))

; ========================================
; Test 3: whenガード条件の複雑なケース
; ========================================
; 理由: ガード条件とパターンの組み合わせをテスト

(println "\nTest 3: Complex when Guards")

(defn classify-with-guard [n]
  (match n
    x when (< x 0) -> "negative"
    x when (= x 0) -> "zero"
    x when (and (> x 0) (< x 10)) -> "small-positive"
    x when (and (>= x 10) (< x 100)) -> "medium"
    x when (>= x 100) -> "large"
    _ -> "unknown"))

(if (and
      (= "negative" (classify-with-guard -5))
      (= "zero" (classify-with-guard 0))
      (= "small-positive" (classify-with-guard 5))
      (= "medium" (classify-with-guard 50))
      (= "large" (classify-with-guard 150)))
  (println "  ✓ whenガード条件成功")
  (println "  ✗ whenガード条件失敗"))

; orパターンとwhenの組み合わせ
(defn classify-even-odd [n]
  (match n
    0 -> "zero"
    x when (= (% x 2) 0) -> "even"
    x when (= (% x 2) 1) -> "odd"
    _ -> "unknown"))

(if (and
      (= "zero" (classify-even-odd 0))
      (= "even" (classify-even-odd 4))
      (= "odd" (classify-even-odd 7)))
  (println "  ✓ orパターン+when成功")
  (println "  ✗ orパターン+when失敗"))

; ========================================
; Test 4: :asバインディングとwhenの組み合わせ
; ========================================
; 理由: パターンマッチング結果を変数に束縛しつつ条件チェック

(println "\nTest 4: :as Binding with when")

(defn process-user [user]
  (match user
    {:name n :age a :as u} when (>= a 18) -> (str n " (adult)")
    {:name n :age a :as u} when (< a 18) -> (str n " (minor)")
    _ -> "invalid"))

(if (and
      (= "Alice (adult)" (process-user {:name "Alice" :age 25}))
      (= "Bob (minor)" (process-user {:name "Bob" :age 15})))
  (println "  ✓ :as + when成功")
  (println "  ✗ :as + when失敗"))

; ========================================
; Test 5: ベクターパターンの複雑なケース
; ========================================
; 理由: リストライクなデータ構造のマッチングをテスト

(println "\nTest 5: Complex Vector Patterns")

(defn describe-vec [v]
  (match v
    [] -> "empty"
    [x] -> (str "single: " x)
    [x y] -> (str "pair: " x " and " y)
    [x y z] -> (str "triple: " x ", " y ", " z)
    [first ...rest] -> (str "list starting with " first)
    _ -> "not a vector"))

(if (and
      (= "empty" (describe-vec []))
      (= "single: 1" (describe-vec [1]))
      (= "pair: 1 and 2" (describe-vec [1 2]))
      (= "triple: 1, 2, 3" (describe-vec [1 2 3]))
      (= "list starting with 1" (describe-vec [1 2 3 4 5])))
  (println "  ✓ ベクターパターン成功")
  (println "  ✗ ベクターパターン失敗"))

; & restパターン
(defn describe-with-rest [v]
  (match v
    [a b & rest] -> (str "first: " a ", second: " b ", rest: " (len rest))
    _ -> "invalid"))

(if (and
      (= "first: 1, second: 2, rest: 3" (describe-with-rest [1 2 3 4 5]))
      (= "first: 1, second: 2, rest: 0" (describe-with-rest [1 2])))
  (println "  ✓ & restパターン成功")
  (println "  ✗ & restパターン失敗"))

; ========================================
; Test 6: マップパターンの複雑なケース
; ========================================
; 理由: 構造化データのマッチングは実世界で頻出

(println "\nTest 6: Complex Map Patterns")

(defn process-request [req]
  (match req
    {:method "GET" :path path} -> (str "GET " path)
    {:method "POST" :path path :body body} -> (str "POST " path " with body")
    {:method "DELETE" :path path} -> (str "DELETE " path)
    {:error error} -> (str "Error: " error)
    _ -> "unknown request"))

(if (and
      (= "GET /users" (process-request {:method "GET" :path "/users"}))
      (= "POST /users with body" (process-request {:method "POST" :path "/users" :body {:name "Alice"}}))
      (= "DELETE /users/1" (process-request {:method "DELETE" :path "/users/1"}))
      (= "Error: Not Found" (process-request {:error "Not Found"})))
  (println "  ✓ マップパターン成功")
  (println "  ✗ マップパターン失敗"))

; ========================================
; Test 7: ネストしたパターンマッチング
; ========================================
; 理由: 深い構造のデータを直接マッチング

(println "\nTest 7: Nested Pattern Matching")

(defn process-nested [data]
  (match data
    {:status "ok" :data {:user {:name n :age a}}}
      -> (str "User: " n " (" a ")")
    {:status "error" :message msg}
      -> (str "Error: " msg)
    _
      -> "unknown"))

(if (and
      (= "User: Alice (30)"
         (process-nested {:status "ok" :data {:user {:name "Alice" :age 30}}}))
      (= "Error: Not Found"
         (process-nested {:status "error" :message "Not Found"})))
  (println "  ✓ ネストパターン成功")
  (println "  ✗ ネストパターン失敗"))

; ========================================
; Test 8: ネストしたmatch
; ========================================
; 理由: matchの中でmatchを使うケースをテスト

(println "\nTest 8: Nested match Expressions")

(defn categorize-value [v]
  (match v
    n when (number? n) ->
      (match n
        x when (< x 0) -> "negative number"
        0 -> "zero"
        x when (> x 0) -> "positive number"
        _ -> "unknown number")
    s when (string? s) ->
      (match s
        "" -> "empty string"
        x when (> (len x) 10) -> "long string"
        _ -> "short string")
    _ -> "other type"))

(if (and
      (= "negative number" (categorize-value -5))
      (= "zero" (categorize-value 0))
      (= "positive number" (categorize-value 10))
      (= "empty string" (categorize-value ""))
      (= "long string" (categorize-value "this is a very long string"))
      (= "short string" (categorize-value "hi")))
  (println "  ✓ ネストしたmatch成功")
  (println "  ✗ ネストしたmatch失敗"))

; ========================================
; Test 9: 実世界のHTTPルーティング
; ========================================
; 理由: Webアプリケーションでよく見るパターン

(println "\nTest 9: Real-world HTTP Routing")

(defn route [req]
  (match req
    {:method "GET" :path "/"}
      -> {:status 200 :body "Home"}
    {:method "GET" :path "/users"}
      -> {:status 200 :body "User List"}
    {:method "GET" :path path} when (str/starts-with? path "/users/")
      -> {:status 200 :body "User Detail"}
    {:method "POST" :path "/users" :body body}
      -> {:status 201 :body "User Created"}
    {:method "PUT" :path path :body body} when (str/starts-with? path "/users/")
      -> {:status 200 :body "User Updated"}
    {:method "DELETE" :path path} when (str/starts-with? path "/users/")
      -> {:status 204 :body ""}
    _
      -> {:status 404 :body "Not Found"}))

(def home (route {:method "GET" :path "/"}))
(def users (route {:method "GET" :path "/users"}))
(def user (route {:method "GET" :path "/users/123"}))
(def create (route {:method "POST" :path "/users" :body {:name "Alice"}}))
(def not-found (route {:method "GET" :path "/unknown"}))

(if (and
      (= 200 (:status home))
      (= 200 (:status users))
      (= 200 (:status user))
      (= 201 (:status create))
      (= 404 (:status not-found)))
  (println "  ✓ HTTPルーティング成功")
  (println "  ✗ HTTPルーティング失敗"))

; ========================================
; Test 10: 状態マシンのパターン
; ========================================
; 理由: matchを使った状態遷移は実用的

(println "\nTest 10: State Machine Pattern")

(defn next-state [state event]
  (match [state event]
    [:idle :start] -> :running
    [:running :pause] -> :paused
    [:paused :resume] -> :running
    [:running :stop] -> :stopped
    [:stopped :start] -> :running
    [s _] -> s))  ; 無効な遷移は状態を保持

(if (and
      (= :running (next-state :idle :start))
      (= :paused (next-state :running :pause))
      (= :running (next-state :paused :resume))
      (= :stopped (next-state :running :stop))
      (= :idle (next-state :idle :invalid)))  ; 無効な遷移
  (println "  ✓ 状態マシン成功")
  (println "  ✗ 状態マシン失敗"))

; ========================================
; Test 11: 大量のパターン（50個）
; ========================================
; 理由: パフォーマンスとメモリ使用量のテスト

(println "\nTest 11: Many Patterns (50 cases)")

(defn match-many [n]
  (match n
    0 -> "zero"    1 -> "one"      2 -> "two"      3 -> "three"    4 -> "four"
    5 -> "five"    6 -> "six"      7 -> "seven"    8 -> "eight"    9 -> "nine"
    10 -> "ten"    11 -> "eleven"  12 -> "twelve"  13 -> "thirteen" 14 -> "fourteen"
    15 -> "fifteen" 16 -> "sixteen" 17 -> "seventeen" 18 -> "eighteen" 19 -> "nineteen"
    20 -> "twenty" 21 -> "twenty-one" 22 -> "twenty-two" 23 -> "twenty-three" 24 -> "twenty-four"
    25 -> "twenty-five" 26 -> "twenty-six" 27 -> "twenty-seven" 28 -> "twenty-eight" 29 -> "twenty-nine"
    30 -> "thirty" 31 -> "thirty-one" 32 -> "thirty-two" 33 -> "thirty-three" 34 -> "thirty-four"
    35 -> "thirty-five" 36 -> "thirty-six" 37 -> "thirty-seven" 38 -> "thirty-eight" 39 -> "thirty-nine"
    40 -> "forty" 41 -> "forty-one" 42 -> "forty-two" 43 -> "forty-three" 44 -> "forty-four"
    45 -> "forty-five" 46 -> "forty-six" 47 -> "forty-seven" 48 -> "forty-eight" 49 -> "forty-nine"
    _ -> "unknown"))

(if (and
      (= "zero" (match-many 0))
      (= "twenty-five" (match-many 25))
      (= "forty-nine" (match-many 49))
      (= "unknown" (match-many 100)))
  (println "  ✓ 大量パターン成功")
  (println "  ✗ 大量パターン失敗"))

; ========================================
; Test 12: 複雑なガード条件の組み合わせ
; ========================================
; 理由: 実世界では複雑なビジネスロジックが入る

(println "\nTest 12: Complex Guard Combinations")

(defn validate-user [user]
  (match user
    {:name n :age a :email e} when (and (> (len n) 0) (>= a 18) (str/contains? e "@"))
      -> "valid adult"
    {:name n :age a :email e} when (and (> (len n) 0) (< a 18) (str/contains? e "@"))
      -> "valid minor"
    {:name n :age a} when (and (> (len n) 0) (>= a 0))
      -> "missing email"
    _
      -> "invalid"))

(if (and
      (= "valid adult" (validate-user {:name "Alice" :age 30 :email "alice@example.com"}))
      (= "valid minor" (validate-user {:name "Bob" :age 15 :email "bob@example.com"}))
      (= "missing email" (validate-user {:name "Charlie" :age 25}))
      (= "invalid" (validate-user {:age 30})))
  (println "  ✓ 複雑ガード条件成功")
  (println "  ✗ 複雑ガード条件失敗"))

(println "\n=== Match Patterns Stress Test Complete ===")
