; ========================================
; パイプラインストレステスト
; ========================================
;
; 目的: Qiの核心であるパイプライン演算子の限界を試す
;
; テスト項目:
; 1. 長いパイプライン（20段階以上）
; 2. |>, ||>, |>?, ~> の組み合わせ
; 3. パイプライン内での複雑な式
; 4. Railway Oriented Programming
; 5. 非同期パイプラインとチャネル
;
; なぜこれが重要か:
; - パイプラインはQiのアイデンティティ
; - データフローが可視化されることを確認
; - エラーハンドリングが自然に組み込めることを確認
; - パフォーマンスが劣化しないことを確認

(println "=== Pipeline Stress Test ===\n")

; ========================================
; Test 1: 長いパイプライン（25段階）
; ========================================
; 理由: 多段階の変換が正しく動作することを確認
;       スタックオーバーフローしないことを確認

(println "Test 1: Long Pipeline (25 stages)")
(def result
  (1
   |> inc          ; 2
   |> (* 2)        ; 4
   |> (+ 10)       ; 14
   |> inc          ; 15
   |> (* 3)        ; 45
   |> (- 5)        ; 40
   |> (/ 2)        ; 20
   |> inc          ; 21
   |> (* 2)        ; 42
   |> (+ 8)        ; 50
   |> (/ 5)        ; 10
   |> (* 10)       ; 100
   |> (+ 50)       ; 150
   |> (- 25)       ; 125
   |> (/ 5)        ; 25
   |> (* 4)        ; 100
   |> inc          ; 101
   |> dec          ; 100
   |> (+ 100)      ; 200
   |> (/ 2)        ; 100
   |> (* 3)        ; 300
   |> (- 50)       ; 250
   |> (/ 5)        ; 50
   |> (* 2)        ; 100
   |> (+ 900)))    ; 1000

(if (= result 1000)
  (println "  ✓ 25段階パイプライン成功")
  (println f"  ✗ 25段階パイプライン失敗: {result} (expected 1000)"))

; ========================================
; Test 2: データ変換パイプライン
; ========================================
; 理由: 実用的なデータ処理パイプライン
;       map, filter, reduce の組み合わせ

(println "\nTest 2: Data Transformation Pipeline")
(def numbers (range 1 101))  ; 1から100

(def sum-of-even-squares
  (numbers
   |> (filter (fn [n] (= (% n 2) 0)))  ; 偶数のみ
   |> (map (fn [n] (* n n)))           ; 二乗
   |> (take 10)                        ; 最初の10個
   |> (reduce + 0)))                   ; 合計

; 2^2 + 4^2 + 6^2 + 8^2 + 10^2 + 12^2 + 14^2 + 16^2 + 18^2 + 20^2
; = 4 + 16 + 36 + 64 + 100 + 144 + 196 + 256 + 324 + 400 = 1540

(if (= sum-of-even-squares 1540)
  (println "  ✓ データ変換パイプライン成功")
  (println f"  ✗ データ変換パイプライン失敗: {sum-of-even-squares}"))

; ========================================
; Test 3: パイプライン内での複雑な式
; ========================================
; 理由: パイプライン内で無名関数や複雑な式が使えることを確認

(println "\nTest 3: Complex Expressions in Pipeline")
(def users
  [{:name "Alice" :age 30 :active true}
   {:name "Bob" :age 25 :active false}
   {:name "Charlie" :age 35 :active true}
   {:name "David" :age 28 :active true}])

(def active-users-avg-age
  (users
   |> (filter (fn [u] (:active u)))
   |> (map (fn [u] (:age u)))
   |> (fn [ages] (/ (reduce + 0 ages) (len ages)))))

; (30 + 35 + 28) / 3 = 31

(if (= active-users-avg-age 31)
  (println "  ✓ 複雑な式パイプライン成功")
  (println f"  ✗ 複雑な式パイプライン失敗: {active-users-avg-age}"))

; ========================================
; Test 4: ネストしたパイプライン
; ========================================
; 理由: パイプライン内でさらにパイプラインが使えることを確認

(println "\nTest 4: Nested Pipelines")
(def data [[1 2 3] [4 5 6] [7 8 9]])

(def transformed
  (data
   |> (map (fn [row]
             (row
              |> (map (fn [x] (* x 2)))
              |> (filter (fn [x] (> x 5)))
              |> sum)))
   |> sum))

; [[2 4 6] [8 10 12] [14 16 18]]
; フィルタ後: [[6] [8 10 12] [14 16 18]]
; 各行の合計: [6, 30, 48]
; 総合計: 84

(if (= transformed 84)
  (println "  ✓ ネストしたパイプライン成功")
  (println f"  ✗ ネストしたパイプライン失敗: {transformed}"))

; ========================================
; Test 5: Railway Pipeline (|>?)
; ========================================
; 理由: エラーハンドリングが自然にパイプラインに組み込めることを確認
;       {:ok ...} と {:error ...} の流れ

(println "\nTest 5: Railway Pipeline (|>?)")
(defn safe-div [x y]
  (if (= y 0)
    {:error "Division by zero"}
    {:ok (/ x y)}))

(defn safe-sqrt [x]
  (if (< x 0)
    {:error "Negative number"}
    {:ok (math/sqrt x)}))

(def result1
  ({:ok 16}
   |>? (fn [x] {:ok (* x 2)})      ; 32
   |>? (fn [x] (safe-div x 4))     ; 8
   |>? safe-sqrt))                 ; 2.828...

(def result2
  ({:ok 16}
   |>? (fn [x] {:ok (* x 2)})
   |>? (fn [x] (safe-div x 0))     ; エラー！
   |>? safe-sqrt))                 ; ここは実行されない

(if (and
      (= :ok (first (keys result1)))
      (= :error (first (keys result2)))
      (= "Division by zero" (get result2 :error)))
  (println "  ✓ Railway Pipeline成功")
  (println "  ✗ Railway Pipeline失敗"))

; ========================================
; Test 6: 並列パイプライン (||>)
; ========================================
; 理由: 並列処理がパイプラインで表現できることを確認

(println "\nTest 6: Parallel Pipeline (||>)")
(def items [1 2 3 4 5 6 7 8 9 10])

; 各要素を2倍にする（並列）
(def doubled
  (items
   ||> (fn [x] (* x 2))
   |> sort))

(if (= doubled [2 4 6 8 10 12 14 16 18 20])
  (println "  ✓ 並列パイプライン成功")
  (println "  ✗ 並列パイプライン失敗"))

; ========================================
; Test 7: tap でデバッグ
; ========================================
; 理由: tapがパイプラインの途中で副作用を実行できることを確認
;       データは変更されずに流れることを確認

(println "\nTest 7: Pipeline with tap")
(def tapped-value (atom nil))

(def result
  (10
   |> (* 2)
   |> (tap (fn [x] (reset! tapped-value x)))  ; 20をatomに記録
   |> (+ 5)))

(if (and (= result 25) (= @tapped-value 20))
  (println "  ✓ tap成功")
  (println "  ✗ tap失敗"))

; ========================================
; Test 8: inspect でデータ観察
; ========================================
; 理由: inspectがデータを整形表示して流すことを確認

(println "\nTest 8: Pipeline with inspect")
(def result
  ([1 2 3]
   |> (map inc)
   |> inspect  ; ここで表示されるが、データはそのまま流れる
   |> sum))

(if (= result 9)
  (println "  ✓ inspect成功")
  (println "  ✗ inspect失敗"))

; ========================================
; Test 9: 文字列処理パイプライン
; ========================================
; 理由: 文字列操作が自然にパイプラインで表現できることを確認

(println "\nTest 9: String Processing Pipeline")
(def text "  Hello, World!  ")

(def processed
  (text
   |> str/trim
   |> str/lower
   |> (str/replace "world" "qi")
   |> str/upper))

(if (= processed "HELLO, QI!")
  (println "  ✓ 文字列処理パイプライン成功")
  (println "  ✗ 文字列処理パイプライン失敗"))

; ========================================
; Test 10: 条件付きパイプライン
; ========================================
; 理由: パイプライン内で条件分岐ができることを確認

(println "\nTest 10: Conditional Pipeline")
(defn process-number [n]
  (n
   |> (fn [x] (if (> x 10) (* x 2) (+ x 10)))
   |> (fn [x] (if (= (% x 2) 0) (/ x 2) (* x 3)))
   |> inc))

(def r1 (process-number 5))   ; 5 -> 15 -> 45 -> 46
(def r2 (process-number 15))  ; 15 -> 30 -> 15 -> 16

(if (and (= r1 46) (= r2 16))
  (println "  ✓ 条件付きパイプライン成功")
  (println "  ✗ 条件付きパイプライン失敗"))

; ========================================
; Test 11: パイプラインとmatchの組み合わせ
; ========================================
; 理由: パイプラインの結果をmatchで分岐できることを確認

(println "\nTest 11: Pipeline + Match")
(defn classify [numbers]
  (numbers
   |> (filter (fn [n] (> n 0)))
   |> (map (fn [n] (* n n)))
   |> sum
   |> (fn [total]
        (match total
          x when (< x 100) -> "small"
          x when (< x 1000) -> "medium"
          x when (< x 10000) -> "large"
          _ -> "huge"))))

(if (and
      (= "small" (classify [1 2 3]))      ; 1+4+9 = 14
      (= "medium" (classify [5 6 7]))     ; 25+36+49 = 110
      (= "large" (classify [10 15 20]))   ; 100+225+400 = 725
      (= "huge" (classify [50 60 70])))   ; 2500+3600+4900 = 11000
  (println "  ✓ パイプライン + match 成功")
  (println "  ✗ パイプライン + match 失敗"))

; ========================================
; Test 12: 極端に長いチェーン（50段階）
; ========================================
; 理由: パフォーマンスとスタック深度の限界テスト

(println "\nTest 12: Extremely Long Pipeline (50 stages)")
(def extreme
  (0
   |> inc |> inc |> inc |> inc |> inc
   |> inc |> inc |> inc |> inc |> inc
   |> inc |> inc |> inc |> inc |> inc
   |> inc |> inc |> inc |> inc |> inc
   |> inc |> inc |> inc |> inc |> inc
   |> inc |> inc |> inc |> inc |> inc
   |> inc |> inc |> inc |> inc |> inc
   |> inc |> inc |> inc |> inc |> inc
   |> inc |> inc |> inc |> inc |> inc
   |> inc |> inc |> inc |> inc |> inc))

(if (= extreme 50)
  (println "  ✓ 50段階パイプライン成功")
  (println f"  ✗ 50段階パイプライン失敗: {extreme}"))

(println "\n=== Pipeline Stress Test Complete ===")
