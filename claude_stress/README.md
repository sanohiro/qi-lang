# Claude Stress Tests - Qi言語包括的ストレステスト

## 概要

このディレクトリには、Qi言語インタプリタの堅牢性、性能、正確性を検証するための包括的なストレステストが含まれています。

**作成目的**:
- パーサーをいじめる（限界を試す）
- 仕様に準拠しつつ、複雑で極端なケースをテスト
- バグや想定外の動作を早期発見
- パフォーマンスのボトルネックを特定
- 実装の品質を継続的に保証

## テストファイル一覧

### 01_parser_stress.qi
**パーサーの限界テスト**

テスト項目:
- 深いネスト（7階層のマップ/ベクター）
- 複雑な分解束縛の組み合わせ
- 不規則な空白、改行、コメントの配置
- 複雑なf-string展開（ネストした式、エスケープ）
- 極端に長い式（50個の引数）
- 空コレクションの分解
- nil/false/0 の区別
- キーワードと文字列の混在
- 巨大なベクター（1000要素）

**なぜ重要か**:
- パーサーのスタックオーバーフローを検出
- レキサーの空白・コメント処理を検証
- メモリリークがないことを確認

### 02_match_stress.qi
**パターンマッチングの全機能テスト**

テスト項目:
- orパターンの複雑な組み合わせ（複数の | 演算子）
- when（ガード条件）と :as束縛の組み合わせ
- 深くネストしたデータ構造のマッチング
- 全てのデータ型のマッチング（nil, bool, int, float, string, keyword, vector, map, function）
- リストの ...rest パターン
- ネストしたmatch
- 大量のパターン（50個）
- 多言語文字列のorパターン
- 複数のワイルドカード

**なぜ重要か**:
- matchはQiの中核機能
- パターン展開が正しいことを確認
- ガード条件の評価順序を検証
- メモリ効率を確認

### 03_pipeline_stress.qi
**パイプライン演算子の性能と正確性テスト**

テスト項目:
- 長いパイプライン（25段階、50段階）
- データ変換パイプライン（filter + map + reduce）
- パイプライン内での複雑な式
- ネストしたパイプライン
- Railway Pipeline（|>? とエラーハンドリング）
- 並列パイプライン（||>）
- tap でのデバッグ
- inspect でのデータ観察
- 文字列処理パイプライン
- 条件付きパイプライン
- パイプラインとmatchの組み合わせ

**なぜ重要か**:
- パイプラインはQiのアイデンティティ
- データフローが可視化されることを確認
- スタック深度の限界を確認
- パフォーマンスが線形であることを確認

### 04_macro_loop_stress.qi
**メタプログラミングと末尾再帰テスト**

テスト項目:
- マクロの基本展開
- マクロの衛生性（変数キャプチャ防止）
- 複雑な準クオート(`)とアンクオート(,)
- マクロでloop/recur生成
- マクロでmatch生成
- loop/recurで階乗（深い再帰）
- loop/recurでフィボナッチ
- loop/recurでリスト処理
- ネストしたマクロ
- マクロでdefn生成
- 極端に深いloop/recur（10000回）
- マクロでDSL生成

**なぜ重要か**:
- マクロはコード生成の要
- 衛生性が保たれないとバグの温床
- 末尾再帰最適化を検証
- スタックオーバーフローしないことを確認

### 05_concurrency_stress.qi
**並行・並列処理の安全性と正確性テスト**

テスト項目:
- 基本的なgo/chan
- 複数のgoroutineからの送信
- atom操作の競合テスト
- 非同期パイプライン（~>）
- 複数の非同期パイプラインの並行実行
- pmap（並列map）
- async/await
- 複数のasyncタスクをawait
- チャネルのバッファ
- プロデューサー・コンシューマーパターン
- 並列パイプライン（||>）
- atomのreset!とswap!の組み合わせ

**なぜ重要か**:
- 並行処理はQiの核心機能
- データ競合がないことを確認
- デッドロックしないことを確認
- スレッドセーフなatom操作を検証

### 06_edge_cases_stress.qi
**境界条件と予期しない入力のテスト**

テスト項目:
- 空コレクションに対する操作
- nil/false/0/"" の厳密な区別
- 極端に大きな/小さな数値
- 特殊文字を含む文字列（エスケープ、Unicode）
- 複数行文字列のエッジケース
- ネストの極限（10階層）
- キーワードのエッジケース（特殊名）
- 高階関数の極端なネスト
- compの極端な使用
- 巨大なマップ（100個のキー）
- 負のインデックス（エラーケース）
- 空文字列キー
- 同一性 vs 等価性
- 相互参照データ
- Unicode文字列の長さ

**なぜ重要か**:
- エッジケースでクラッシュしないことを確認
- 予期しない動作をしないことを確認
- エラーメッセージが適切であることを確認

### 07_let_destructuring_stress.qi
**let分解束縛の徹底的なテスト**

テスト項目:
- 多重ネストしたベクター分解（4階層）
- 複雑なマップ分解（深いネスト）
- マップとベクターの混在分解（APIレスポンス風）
- :asバインディングの複雑なケース
- ...restと& restの様々なパターン
- letの中でletを使う複雑なスコープ
- 実世界のHTTPリクエスト処理パターン
- 関数引数の分解パターン
- 複数の分解を連続して行う
- nilや空の値の分解
- 変数シャドーイング
- クロージャでの分解
- 数値・文字列キーを持つマップ

**なぜ重要か**:
- letはQiで最も頻繁に使われる構文
- 実世界のコードパターンを網羅
- ユーザーが実際に書く複雑な分解を想定
- スコープ管理のバグを検出

### 08_match_patterns_stress.qi
**matchパターンの徹底的なテスト**

テスト項目:
- 全てのリテラル型のマッチング
- 複雑なorパターン（数値、文字列）
- whenガード条件の複雑なケース
- :asバインディングとwhenの組み合わせ
- ベクターパターンの複雑なケース
- & restパターン
- マップパターンの複雑なケース
- ネストしたパターンマッチング
- ネストしたmatch式
- 実世界のHTTPルーティング
- 状態マシンのパターン
- 大量のパターン（50ケース）
- 複雑なガード条件の組み合わせ

**なぜ重要か**:
- matchはQiの強力な機能の一つ
- パターンの組み合わせは無限
- 実装の複雑さからバグが出やすい
- 実用的なパターンを網羅

### 09_macro_expansion_stress.qi
**マクロ展開の徹底的なテスト**

テスト項目:
- 基本的なマクロ展開
- 複雑なquasiquote/unquote
- ネストしたquasiquote
- unquote-spliceの使用
- マクロの衛生性（変数キャプチャ防止）
- 条件付きコード生成
- ループ展開マクロ
- アサーションマクロ
- スレッディングマクロ
- DSL作成（HTMLジェネレータ）
- 関数定義マクロ
- matchライクなマクロ
- 時間計測マクロ
- コメントマクロ
- デバッグマクロ
- 複数定義マクロ

**なぜ重要か**:
- マクロはQiの強力な機能
- メタプログラミングは実装が複雑
- 衛生性のバグは見つけにくい
- 実用的なマクロパターンを網羅

## 実行方法

### 個別テストの実行

```bash
# パーサーストレステスト
qi claude_stress/01_parser_stress.qi

# matchストレステスト
qi claude_stress/02_match_stress.qi

# パイプラインストレステスト
qi claude_stress/03_pipeline_stress.qi

# マクロとloop/recurストレステスト
qi claude_stress/04_macro_loop_stress.qi

# 並行処理ストレステスト
qi claude_stress/05_concurrency_stress.qi

# エッジケースストレステスト
qi claude_stress/06_edge_cases_stress.qi

# let分解束縛ストレステスト
qi claude_stress/07_let_destructuring_stress.qi

# matchパターンストレステスト
qi claude_stress/08_match_patterns_stress.qi

# マクロ展開ストレステスト
qi claude_stress/09_macro_expansion_stress.qi
```

### 全テストの一括実行

```bash
qi claude_stress/run_all.qi
```

## テスト結果の見方

各テストは以下の形式で結果を出力します：

```
✓ テスト名 成功
✗ テスト名 失敗: 詳細情報
```

- `✓` = テスト成功
- `✗` = テスト失敗（実装のバグまたは未実装機能）

## テストの設計思想

### 1. 仕様準拠
すべてのテストは `docs/spec` の仕様に基づいています。仕様に記載されていない機能は使用していません。

### 2. いじめるが壊さない
限界を試しますが、無限ループや意図的なクラッシュは含まれていません。

### 3. 実用的
理論上の極端なケースではなく、実世界で遭遇しうる複雑さをテストします。

### 4. 段階的
基本的なケースから始めて、徐々に複雑になるように設計されています。

### 5. 自己文書化
各テストにはコメントで「なぜこのテストが重要か」が記載されています。

## 期待される結果

すべてのテストが成功することが理想ですが、以下のような失敗は許容されます：

1. **未実装機能**: 仕様にあるが未実装の機能
2. **パフォーマンス**: 極端に遅い場合（要最適化）
3. **既知のバグ**: 既に認識されているバグ

失敗したテストは、実装の改善点を示す指標となります。

## 継続的改善

新しい機能を追加したら、対応するストレステストも追加してください：

1. 新機能の基本動作
2. エッジケース
3. 他機能との組み合わせ
4. パフォーマンス境界

## ライセンス

このテストスイートはQi言語プロジェクトの一部であり、同じライセンスに従います。
