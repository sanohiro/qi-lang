; ========================================
; パーサーストレステスト
; ========================================
;
; 目的: パーサーの限界を試し、構文解析の堅牢性を検証する
;
; テスト項目:
; 1. 深くネストしたデータ構造と分解束縛
; 2. 不規則な空白、改行、コメントの配置
; 3. 複雑なf-string展開
; 4. 長い式と多重ネスト
; 5. エッジケース（空、nil、極端な値）
;
; なぜこれが重要か:
; - 実世界のコードは整形されていないことが多い
; - ネストの深さに制限がないことを保証
; - パーサーがメモリを適切に管理していることを確認
; - エラーメッセージが適切に出ることを確認

(println "=== Parser Stress Test ===\n")

; ========================================
; Test 1: 深いネスト（7階層）
; ========================================
; 理由: パーサーのスタック深度をテスト
;       再帰下降パーサーのスタックオーバーフロー検出

(println "Test 1: Deep Nesting (7 levels)")
(def deeply-nested
  {:level1 {:level2 {:level3 {:level4 {:level5 {:level6 {:level7 "deep"}}}}}}})

(let [{:level1 {:level2 {:level3 {:level4 {:level5 {:level6 {:level7 value}}}}}}} deeply-nested]
  (if (= value "deep")
    (println "  ✓ 7階層のネスト分解成功")
    (println "  ✗ 深いネスト分解失敗")))

; ========================================
; Test 2: 複雑な分解束縛の組み合わせ
; ========================================
; 理由: ベクター、マップ、...restの複雑な組み合わせ
;       パーサーの文脈切り替えをテスト

(println "\nTest 2: Complex Destructuring")
(def complex-data
  {:users [{:name "Alice" :scores [95 87 92]}
           {:name "Bob" :scores [78 85 90]}
           {:name "Charlie" :scores [88 92 85]}]
   :meta {:total 3 :avg 87.5}})

(let [{:users users-list :meta meta-data} complex-data
      first-user (first users-list)
      {:name n1 :scores scores-list} first-user
      s1 (first scores-list)]
  (if (and (= n1 "Alice") (= s1 95) (= (:total meta-data) 3) (= (len users-list) 3))
    (println "  ✓ 複雑な分解束縛成功")
    (println "  ✗ 複雑な分解束縛失敗")))

; ========================================
; Test 3: 不規則な空白とコメント
; ========================================
; 理由: レキサーが空白・改行・コメントを正しく無視することを確認
;       実世界のコードは整形されていない

(println "\nTest 3: Irregular Whitespace and Comments")
(def irregular
  [
    1    ; コメント1

    2     ; コメント2


    3     ; コメント3
    4  5      6
    7 8    9
  ]
)

(if (= irregular [1 2 3 4 5 6 7 8 9])
  (println "  ✓ 不規則な空白を正しく処理")
  (println "  ✗ 不規則な空白の処理失敗"))

; マップでも同様のテスト
(def irregular-map
  {
    :a    1
    :b
    2

    :c   3   :d
    4
  }
)

(if (= irregular-map {:a 1 :b 2 :c 3 :d 4})
  (println "  ✓ マップの不規則な空白を正しく処理")
  (println "  ✗ マップの不規則な空白処理失敗"))

; ========================================
; Test 4: 複雑なf-string（ネストした式）
; ========================================
; 理由: f-string内の式パーサーが正しく動作することを確認
;       中括弧のバランスが取れていることを確認

(println "\nTest 4: Complex f-string")
(def data {:x 10 :y 20})
(def items [1 2 3 4 5])

(def result f"Sum: {(+ (:x data) (:y data))}, Product: {(* (:x data) (:y data))}, Items: {(len items)}, First: {(first items)}, Last: {(last items)}")

(if (= result "Sum: 30, Product: 200, Items: 5, First: 1, Last: 5")
  (println "  ✓ 複雑なf-string展開成功")
  (println "  ✗ 複雑なf-string展開失敗"))

; エスケープのテスト
(def escaped f"Escaped: \{not-a-var\}, Normal: {(:x data)}")
(if (= escaped "Escaped: {not-a-var}, Normal: 10")
  (println "  ✓ f-stringエスケープ成功")
  (println "  ✗ f-stringエスケープ失敗"))

; ========================================
; Test 5: 複数行の複雑なf-string
; ========================================
; 理由: 複数行文字列とf-stringの組み合わせ
;       改行の扱いが正しいことを確認

(println "\nTest 5: Multi-line f-string")
(def user {:name "Alice" :age 30 :city "Tokyo"})
(def report f"""
Name: {(:name user)}
Age: {(:age user)}
City: {(:city user)}
Status: {(if (>= (:age user) 20) "Adult" "Minor")}
""")

(if (str/contains? report "Name: Alice")
  (println "  ✓ 複数行f-string成功")
  (println "  ✗ 複数行f-string失敗"))

; ========================================
; Test 6: 極端に長い式
; ========================================
; 理由: パーサーがメモリを効率的に使用していることを確認
;       大きなASTを生成できることを確認

(println "\nTest 6: Long Expression")
(def long-sum
  (+ 1 2 3 4 5 6 7 8 9 10
     11 12 13 14 15 16 17 18 19 20
     21 22 23 24 25 26 27 28 29 30
     31 32 33 34 35 36 37 38 39 40
     41 42 43 44 45 46 47 48 49 50))

(if (= long-sum 1275)
  (println "  ✓ 長い式の評価成功")
  (println "  ✗ 長い式の評価失敗"))

; ========================================
; Test 7: エッジケース - 空コレクション
; ========================================
; 理由: 境界条件の処理を確認
;       空の場合の特別処理が正しいことを確認

(println "\nTest 7: Empty Collections")
(def empty-vec [])
(def empty-map {})
(def empty-list '())

(let [[] empty-vec
      {} empty-map]
  (println "  ✓ 空コレクションの分解成功"))

; 空コレクションに対する操作
(if (and
      (= 0 (len empty-vec))
      (= 0 (len empty-map))
      (= nil (first empty-vec))
      (= nil (get empty-map :key)))
  (println "  ✓ 空コレクションの操作成功")
  (println "  ✗ 空コレクションの操作失敗"))

; ========================================
; Test 8: nil/false/0 の区別
; ========================================
; 理由: これらは異なる値だが、条件式では全てfalsyにならない
;       (0と""はtruthyである点がQiの特徴)

(println "\nTest 8: nil/false/0 Distinction")
(def values [nil false 0 "" []])

(let [results (map (fn [v]
                     {:value v
                      :is-nil (= v nil)
                      :is-false (= v false)
                      :is-zero (= v 0)
                      :truthy (if v true false)})
                   values)]
  (if (and
        (= true (get (first results) :is-nil))
        (= true (get (nth results 1) :is-false))
        (= true (get (nth results 2) :is-zero))
        (= false (get (first results) :truthy))
        (= false (get (nth results 1) :truthy))
        (= true (get (nth results 2) :truthy)))  ; 0はtruthy
    (println "  ✓ nil/false/0の区別成功")
    (println "  ✗ nil/false/0の区別失敗")))

; ========================================
; Test 9: 複雑なletチェーン
; ========================================
; 理由: スコープの管理が正しいことを確認
;       シャドーイングが正しく機能することを確認

(println "\nTest 9: Complex let Chains")
(let [x 1]
  (let [x 2 y x]  ; y は新しい x (2) を参照
    (let [x 3 z (+ x y)]  ; z は 3 + 2
      (if (and (= x 3) (= y 2) (= z 5))
        (println "  ✓ letチェーンのスコープ管理成功")
        (println "  ✗ letチェーンのスコープ管理失敗")))))

; ========================================
; Test 10: キーワードと文字列の混在
; ========================================
; 理由: マップのキーとして両方が使えることを確認
;       同じ名前でも異なるキーとして扱われることを確認

(println "\nTest 10: Keywords and Strings as Keys")
(def mixed-keys {:name "Alice" "name" "Bob" :age 30 "age" 25})

(if (and
      (= "Alice" (:name mixed-keys))
      (= "Bob" (get mixed-keys "name"))
      (= 30 (:age mixed-keys))
      (= 25 (get mixed-keys "age")))
  (println "  ✓ キーワードと文字列の混在成功")
  (println "  ✗ キーワードと文字列の混在失敗"))

; ========================================
; Test 11: 巨大なベクター（1000要素）
; ========================================
; 理由: 大きなデータ構造を効率的に扱えることを確認
;       メモリリークがないことを確認

(println "\nTest 11: Large Vector (1000 elements)")
(def large-vec (range 1000))

(if (and
      (= 1000 (len large-vec))
      (= 0 (first large-vec))
      (= 999 (last large-vec))
      (= 499500 (reduce + 0 large-vec)))
  (println "  ✓ 1000要素ベクターの処理成功")
  (println "  ✗ 1000要素ベクターの処理失敗"))

; ========================================
; Test 12: ネストしたコメント（実際にはネストしない）
; ========================================
; 理由: コメント内のコメント記号が問題を起こさないことを確認

(println "\nTest 12: Comments with Comment Symbols")
(def x 42) ; このコメントには ; セミコロンが ; 複数ある
; ; ; 連続セミコロン
;;; 3つ連続

(if (= x 42)
  (println "  ✓ コメント内のセミコロン処理成功")
  (println "  ✗ コメント内のセミコロン処理失敗"))

(println "\n=== Parser Stress Test Complete ===")
