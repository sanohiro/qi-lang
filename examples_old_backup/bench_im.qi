;; im::Vector と im::HashMap のパフォーマンス確認

(println "=== Persistent Data Structures パフォーマンステスト ===")
(println "")

;; リスト操作のテスト
(println "1. 大きなリストの作成と操作")
(def large-list (range 10000))
(println (str "  - 10000要素のリスト作成完了: " (count large-list) "要素"))

;; cloneは内部で自動的に行われる（値渡しの際など）
(def list-copy large-list)
(println (str "  - リストをコピー（構造共有）: " (count list-copy) "要素"))

;; リストへの追加（イミュータブルなので新しいリストが作成される）
(def extended-list (conj large-list 10000 10001 10002))
(println (str "  - 要素を追加（元のリストは変更されない）: " (count extended-list) "要素"))
(println (str "  - 元のリスト: " (count large-list) "要素（変更されていない）"))
(println "")

;; マップ操作のテスト
(println "2. 大きなマップの作成と操作")
(def large-map
  (reduce
    (fn [m i] (assoc m (str "key-" i) i))
    {}
    (range 1000)))
(println (str "  - 1000エントリのマップ作成完了: " (count large-map) "エントリ"))

;; マップの更新（イミュータブル）
(def updated-map (assoc large-map "new-key" 9999))
(println (str "  - 新しいエントリを追加: " (count updated-map) "エントリ"))
(println (str "  - 元のマップ: " (count large-map) "エントリ（変更されていない）"))
(println "")

;; ネストした構造
(println "3. ネストしたデータ構造")
(def nested-data
  (map
    (fn [i]
      {:id i
       :name (str "item-" i)
       :tags (range 10)
       :meta {:created i :updated (+ i 1)}})
    (range 100)))
(println (str "  - 100個のネストした構造を作成: " (count nested-data) "個"))

;; フィルタリング（元のデータは変更されない）
(def filtered (filter (fn [item] (> (:id item) 50)) nested-data))
(println (str "  - 条件でフィルタリング: " (count filtered) "個"))
(println (str "  - 元のデータ: " (count nested-data) "個（変更されていない）"))
(println "")

;; バージョン管理のような使い方
(println "4. イミュータブルなデータのバージョン管理")
(def v1 {:name "test" :version 1 :data [1 2 3]})
(def v2 (assoc v1 :version 2))
(def v3 (assoc v2 :data [1 2 3 4 5]))
(println "  - バージョン1:" v1)
(println "  - バージョン2:" v2)
(println "  - バージョン3:" v3)
(println "  → 全てのバージョンが独立して存在（構造共有により効率的）")
(println "")

(println "=== テスト完了 ===")
(println "im::Vector と im::HashMap により:")
(println "  ✓ clone操作が高速（O(1)）")
(println "  ✓ 構造共有によりメモリ効率が向上")
(println "  ✓ イミュータブルなデータ構造")
(println "  ✓ 並行処理に安全")
